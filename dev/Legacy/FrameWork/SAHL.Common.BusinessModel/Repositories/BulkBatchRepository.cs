using System;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Text;
using Castle.ActiveRecord;
using Castle.ActiveRecord.Queries;
using SAHL.Common.Attributes;
using SAHL.Common.BusinessModel.DAO;
using SAHL.Common.BusinessModel.Interfaces;
using SAHL.Common.BusinessModel.Interfaces.Repositories;
using SAHL.Common.BusinessModel.Interfaces.Service;
using SAHL.Common.BusinessModel.Service;
using SAHL.Common.BusinessModel.Validation;
using SAHL.Common.CacheData;
using SAHL.Common.Collections;
using SAHL.Common.Collections.Interfaces;
using SAHL.Common.DataAccess;
using SAHL.Common.Exceptions;
using SAHL.Common.Security;

namespace SAHL.Common.BusinessModel.Repositories
{
    [FactoryType(typeof(IBulkBatchRepository))]
    public class BulkBatchRepository : AbstractRepositoryBase, IBulkBatchRepository
    {
        /// <summary>
        /// Repository Methods to retrieve Batch and Bulk Transactions
        /// </summary>
        public BulkBatchRepository()
        {
            if (castleTransactionService == null)
            {
                castleTransactionService = new CastleTransactionsService();
            }
        }

        public BulkBatchRepository(ICastleTransactionsService castleTransactionService)
        {
            this.castleTransactionService = castleTransactionService;
        }

        private ICastleTransactionsService castleTransactionService;

        public IReadOnlyEventList<IFinancialTransaction> GetBatchLoanTransactions(int AccountKey, int TransactionTypeNumber, DateTime TransactionEffectiveDate, string TransactionReference, string ADUserName)
        {
            string HQL = @"from FinancialTransaction_DAO lt where lt.FinancialService.Account.Key = ?
							and lt.TransactionType.Key = ? and lt.Reference = ?
							and lt.EffectiveDate = ? and lt.UserID = ?";
            SimpleQuery<FinancialTransaction_DAO> query = new SimpleQuery<FinancialTransaction_DAO>(HQL, AccountKey, TransactionTypeNumber, TransactionReference, TransactionEffectiveDate, ADUserName);
            FinancialTransaction_DAO[] lts = query.Execute();

            IEventList<IFinancialTransaction> list = new DAOEventList<FinancialTransaction_DAO, IFinancialTransaction, FinancialTransaction>(lts);
            return new ReadOnlyEventList<IFinancialTransaction>(list);
        }

        public IBatchTransaction GetBatchTransactionByKey(int Key)
        {
            return base.GetByKey<IBatchTransaction, BatchTransaction_DAO>(Key);
        }

        // TODO: transactions shouldn't exist in the repositories!
        public void PostTransaction(int BatchTransactionKey, int AccountKey, int TransactionTypeNumber, DateTime TransactionEffectiveDate, float TransactionAmount, string TransactionReference, string ADUserName)
        {
            TransactionScope trans = new TransactionScope();

            using (trans)
            {
                try
                {
                    ParameterCollection prms = new ParameterCollection();
                    prms.Add(new SqlParameter("@AccountKey", AccountKey));
                    prms.Add(new SqlParameter("@TransactionTypeNumber", TransactionTypeNumber));
                    prms.Add(new SqlParameter("@TransactionEffectiveDate", TransactionEffectiveDate));
                    prms.Add(new SqlParameter("@TransactionAmount", TransactionAmount));
                    prms.Add(new SqlParameter("@TransactionReference", TransactionReference));
                    prms.Add(new SqlParameter("@UserId", ADUserName));

                    object obj = castleTransactionService.ExecuteScalarOnCastleTran("EXEC [2AM].[dbo].pLoanProcessTran @AccountKey, @TransactionTypeNumber, @TransactionEffectiveDate, @TransactionAmount, @TransactionReference, @UserId", typeof(Account_DAO), prms);

                    int result = Convert.ToInt32(obj);

                    if (result == 0)
                    {
                        //If successfully posted, the method must then go and find the successfully  posted loan transaction
                        //and update the  BatchLoanTransaction table with the BatchTransactionKey and the  FinancialTransaction number generated by the transaction.

                        // - UIStatement: FindLoanProcessTran
                        string query = UIStatementRepository.GetStatement("COMMON", "FindLoanProcessTran");
                        prms = new ParameterCollection();
                        prms.Add(new SqlParameter("@l_LoanNumber", AccountKey));
                        prms.Add(new SqlParameter("@i_TransactionTypeNumber", TransactionTypeNumber));
                        prms.Add(new SqlParameter("@s_TransactionEffectiveDate", TransactionEffectiveDate));
                        prms.Add(new SqlParameter("@s_TransactionReference", TransactionReference));
                        prms.Add(new SqlParameter("@s_UserId", ADUserName));

                        object ltobj = castleTransactionService.ExecuteScalarOnCastleTran(query, typeof(Account_DAO), prms);

                        int loanTransactionNumber = Convert.ToInt32(ltobj);

                        //set BatchTransactionStatusKey = 3 where BatchTransaction.Key = BatchTransactionKey

                        BatchTransaction bt = new BatchTransaction(BatchTransaction_DAO.Find(BatchTransactionKey));
                        bt.BatchTransactionStatus = new BatchTransactionStatus(BatchTransactionStatus_DAO.Find(3));
                        SaveBatchTransaction(bt);

                        //create new batchLoanTransaction with the loanTransactionNumber
                        IBatchLoanTransaction blt = GetEmptyBatchLoanTransaction();
                        blt.LoanTransactionNumber = loanTransactionNumber;
                        blt.BatchTransaction = bt;
                        SaveBatchLoanTransaction(blt);
                    }
                    else
                    {
                        BatchTransaction bt = new BatchTransaction(BatchTransaction_DAO.Find(BatchTransactionKey));
                        bt.BatchTransactionStatus = new BatchTransactionStatus(BatchTransactionStatus_DAO.Find(2));
                        SaveBatchTransaction(bt);
                    }
                }
                catch (Exception ex)
                {
                    trans.VoteRollBack();
                    throw ex;
                }

                if (ValidationHelper.PrincipalHasValidationErrors())
                    throw new DomainValidationException();

                trans.VoteCommit();
            }

            //0 = ok
            //2 RAISERROR('pLoanProcessTran: Error in pLoanProcessUnpaidDO', 7, 1)
            //4 RAISERROR('Corrections can''t be posted for Flexi Product - contact Finance', 7, 1)
            //11 RAISERROR('pLoanProcessTran: Incorrect transaction group (5,6)', 7, 1)
            //12 RAISERROR('pLoanProcessTran: Incorrect transaction group (1,2,3)', 7, 1)
            //13 RAISERROR('pLoanProcessTran: Incorrect transaction group (1,2,3): Too many entries', 7, 1)
            //14 RAISERROR('pLoanProcessTran: Incorrect transaction group (1,2,3): More than one 1', 7, 1)
            //15 RAISERROR('pLoanProcessTran: Incorrect transaction group (1,2,3): More than one 2', 7, 1)
            //16 RAISERROR('pLoanProcessTran: Incorrect transaction group (1,2,3): More than one 3', 7, 1)
            //17 RAISERROR('pLoanProcessTran: Incorrect transaction group (1,2,3): Critical error determining group', 7, 1)
            //18 RAISERROR('pLoanProcessTran: No transaction in #TranTablePost', 7, 1)
            //19 RAISERROR('pLoanProcessTran: #TranTablePost: Incorrect values for posting', 7, 1)
            //20 RAISERROR('pLoanProcessTran: #TranTablePost: Invalid PostTranTypeGroup', 7, 1)
            //22 RAISERROR('pLoanProcessTran: Error in pLoanPostFinTran', 7, 1)
            //23 RAISERROR('pLoanProcessTran: #TranTablePost: Not all transactions were posted', 7, 1)
            //31 RAISERROR('EffectiveDate > Today', 1, 2)
            //32 RAISERROR('EffectiveDate < 1st of last month', 1, 2)
            //33 RAISERROR('EffectiveDate < 1st of current month', 1, 2)
            //34 RAISERROR('pLoanProcessTran: Transaction Amount < 0.01', 1, 2)
            //35 RAISERROR('Invalid Transaction Type Number',1,2)
            //36 RAISERROR('Loan Number Invalid in 2AM',1,2)
            //37 RAISERROR('Transaction amount cannot be less than one cent!',7,2)
        }

        /// <summary>
        /// Implements <see cref="IBulkBatchRepository.GetEmptyBulkBatch()"></see>.
        /// </summary>
        public IBulkBatch GetEmptyBulkBatch()
        {
            return base.CreateEmpty<IBulkBatch, BulkBatch_DAO>();
        }

        public IBulkBatchParameter GetEmptyBulkBatchParameter()
        {
            return base.CreateEmpty<IBulkBatchParameter, BulkBatchParameter_DAO>();
        }

        public void SaveBulkBatch(IBulkBatch bk)
        {
            base.Save<IBulkBatch, BulkBatch_DAO>(bk);
        }

        public DataTable GetUpdateBulkTransactionBatchByBulkBatchKey(int BulkBatchKey)
        {
            string query = UIStatementRepository.GetStatement("COMMON", "GetUpdateBulkTransactionBatchByBulkBatchKey");
            ParameterCollection prms = new ParameterCollection();
            prms.Add(new SqlParameter("@BulkBatchKey", BulkBatchKey));

            DataSet ds = this.castleTransactionService.ExecuteQueryOnCastleTran(query, typeof(Account_DAO), prms);

            if (ds != null && ds.Tables.Count > 0)
                return ds.Tables[0];

            return new DataTable();
        }

        public DataTable GetAddBulkTransactionBatchBySubsidyProviderKey(int SubsidyProviderKey, int[] OriginationSourceKeys)
        {
            // Refactor FXCop Error Message - DoNotConcatenateStringsInsideLoops
            //string osKeys = "";
            StringBuilder osKeys = new StringBuilder();

            for (int i = 0; i < OriginationSourceKeys.Length; i++)
            {
                // osKeys += "," + OriginationSourceKeys[i].ToString();
                osKeys.AppendFormat(",{0}", OriginationSourceKeys[i].ToString());
            }

            if (osKeys.ToString().StartsWith(","))
                osKeys = osKeys.Remove(0, 1);

            string sql = UIStatementRepository.GetStatement("COMMON", "GetAddBulkTransactionBatchBySubsidyProviderKey");
            string query = String.Format(sql, osKeys.ToString());

            ParameterCollection prms = new ParameterCollection();
            prms.Add(new SqlParameter("@SubsidyProviderKey", SubsidyProviderKey));

            DataSet ds = this.castleTransactionService.ExecuteQueryOnCastleTran(query, typeof(Account_DAO), prms);

            if (ds != null && ds.Tables.Count > 0)
                return ds.Tables[0];

            return new DataTable();
        }

        /// <summary>
        /// Get BulkBatch Transactions given BulkBatchTypeKey
        /// </summary>
        /// <param name="bulkBatchTypeKey"></param>
        /// <returns></returns>
        public IList<IBulkBatch> GetBulkBatchTransactionsByBulkBatchTypeKey(int bulkBatchTypeKey)
        {
            // This query needs to be able to read uncommitted data to determine the status of the Batch Job.
            // The reason for this is the Update of the Status happens with a session so the data is uncommitted.
            string sql = @"select bb.* from [2am].[dbo].BulkBatch bb (nolock)
            where bb.BulkBatchTypeKey = ? order by bb.BulkBatchKey desc";
            SimpleQuery<BulkBatch_DAO> q = new SimpleQuery<BulkBatch_DAO>(QueryLanguage.Sql, sql, bulkBatchTypeKey);
            q.AddSqlReturnDefinition(typeof(BulkBatch_DAO), "bb");
            q.SetQueryRange(30);
            BulkBatch_DAO[] res = q.Execute();

            IList<IBulkBatch> retval = new List<IBulkBatch>();
            for (int i = 0; i < res.Length; i++)
            {
                retval.Add(new BulkBatch(res[i]));
            }
            return retval;
        }

        /// <summary>
        /// Get BulkBatch Transactions given BatchTypeKey and Status Key
        /// </summary>
        /// <param name="bulkBatchTypeKey"></param>
        /// <param name="bulkBatchStatusKey"></param>
        /// <returns></returns>
        public IList<IBulkBatch> GetBulkBatchByBulkBatchTypeAndStatusKey(int bulkBatchTypeKey, int bulkBatchStatusKey)
        {
            string HQL = "from BulkBatch_DAO b where b.BulkBatchType.Key = ? and b.BulkBatchStatus.Key = ? order by b.Key desc";
            SimpleQuery<BulkBatch_DAO> q = new SimpleQuery<BulkBatch_DAO>(HQL, bulkBatchTypeKey, bulkBatchStatusKey);
            BulkBatch_DAO[] res = q.Execute();

            IList<IBulkBatch> retval = new List<IBulkBatch>();

            for (int i = 0; i < res.Length; i++)
            {
                retval.Add(new BulkBatch(res[i]));
            }
            return retval;
        }

        /// <summary>
        /// Get BatchLogTransactions Given BulkBatchKey MessageTypeKey
        /// </summary>
        /// <param name="bulkBatchKey"></param>
        /// <param name="messageTypeKey"></param>
        /// <returns></returns>
        public IList<IBulkBatchLog> GetBatchLogByBatchKeyMessageType(int bulkBatchKey, int messageTypeKey)
        {
            string HQL = "from BulkBatchLog_DAO b where b.BulkBatch.Key = ? and b.MessageType.Key = ?";
            SimpleQuery<BulkBatchLog_DAO> q = new SimpleQuery<BulkBatchLog_DAO>(HQL, bulkBatchKey, messageTypeKey);
            BulkBatchLog_DAO[] res = q.Execute();

            IList<IBulkBatchLog> retval = new List<IBulkBatchLog>();

            for (int i = 0; i < res.Length; i++)
            {
                retval.Add(new BulkBatchLog(res[i]));
            }
            return retval;
        }

        /// <summary>
        /// Gets the BulkBatchTransaction by Bulk Batch Key
        /// </summary>
        /// <param name="BulkBatchKey"></param>
        /// <returns></returns>
        public DataTable GetBatchTransactionByBulkBatchKey(int BulkBatchKey)
        {
            string query = UIStatementRepository.GetStatement("COMMON", "GetBatchTransactionByBulkBatchKey");
            ParameterCollection prms = new ParameterCollection();
            prms.Add(new SqlParameter("@BulkBatchKey", BulkBatchKey));

            DataSet ds = this.castleTransactionService.ExecuteQueryOnCastleTran(query, typeof(GeneralStatus_DAO), prms);

            if (ds != null && ds.Tables.Count > 0)
                return ds.Tables[0];

            return new DataTable();
        }

        /// <summary>
        /// Get BatchTransactions given BulkBatchKey
        /// </summary>
        /// <param name="bulkBatchKey"></param>
        /// <returns></returns>
        public IList<IBatchTransaction> GetBatchTransactionsByBulkBatchKey(int bulkBatchKey)
        {
            string HQL = "from BatchTransaction_DAO b where b.BulkBatch.Key = ?";
            SimpleQuery<BatchTransaction_DAO> q = new SimpleQuery<BatchTransaction_DAO>(HQL, bulkBatchKey);
            BatchTransaction_DAO[] res = q.Execute();

            List<IBatchTransaction> retval = new List<IBatchTransaction>();

            for (int i = 0; i < res.Length; i++)
            {
                retval.Add(new BatchTransaction(res[i]));
            }
            return retval;
        }

        /// <summary>
        /// Implements <see cref="IBulkBatchRepository.GetEmptyBatchTransaction()"></see>.
        /// </summary>
        public IBatchTransaction GetEmptyBatchTransaction()
        {
            return base.CreateEmpty<IBatchTransaction, BatchTransaction_DAO>();
        }

        /// <summary>
        /// Saves a batch Transaction
        /// </summary>
        /// <param name="bt"></param>
        public void SaveBatchTransaction(IBatchTransaction bt)
        {
            base.Save<IBatchTransaction, BatchTransaction_DAO>(bt);
        }

        public IBatchLoanTransaction GetEmptyBatchLoanTransaction()
        {
            return base.CreateEmpty<IBatchLoanTransaction, BatchLoanTransaction_DAO>();
        }

        /// <summary>
        /// Saves a batch Transaction
        /// </summary>
        /// <param name="blt"></param>
        public void SaveBatchLoanTransaction(IBatchLoanTransaction blt)
        {
            base.Save<IBatchLoanTransaction, BatchLoanTransaction_DAO>(blt);
        }

        /// <summary>
        /// Gets a list of Subsidy Providers
        /// </summary>
        /// <param name="subsidyProviderTypeKey"></param>
        /// <returns></returns>
        public IList<ISubsidyProvider> GetSubsidyProviderBySubsidyProviderTypeKey(int subsidyProviderTypeKey)
        {
            string SQL = String.Format(@"select sp.*
                    from subsidyProvider sp (nolock)
                    JOIN LegalEntity LES (nolock) on sp.LegalEntityKey = LES.LegalEntityKey
                    WHERE sp.SubsidyProviderTypeKey = {0}
                    order by LES.RegisteredName", subsidyProviderTypeKey);

            SimpleQuery<SubsidyProvider_DAO> q = new SimpleQuery<SubsidyProvider_DAO>(QueryLanguage.Sql, SQL);
            q.AddSqlReturnDefinition(typeof(SubsidyProvider_DAO), "sp");
            SubsidyProvider_DAO[] res = q.Execute();

            List<ISubsidyProvider> retval = new List<ISubsidyProvider>();

            for (int i = 0; i < res.Length; i++)
            {
                retval.Add(new SubsidyProvider(res[i]));
            }
            return retval;
        }

        /// <summary>
        /// Get Transaction Type by Key
        /// </summary>
        /// <param name="transactionTypeKey"></param>
        /// <returns></returns>
        public ITransactionType GetTransactionTypeByKey(int transactionTypeKey)
        {
            TransactionType_DAO tt = TransactionType_DAO.Find(transactionTypeKey);
            return new TransactionType(tt);
        }

        // This method no longer excludes memo transactions
        public IReadOnlyEventList<ITransactionType> GetLoanTransactionTypes(SAHLPrincipal principal)
        {
            SAHLPrincipalCache spc = SAHLPrincipalCache.GetPrincipalCache(principal);
            string groups = spc.GetCachedRolesAsStringForQuery(true, false);

            string query = UIStatementRepository.GetStatement("Repositories.BulkBatchRepository", "GetLoanTransactionTypes");
            string sql = String.Format(query, groups);

            SimpleQuery<TransactionType_DAO> q = new SimpleQuery<TransactionType_DAO>(QueryLanguage.Sql, sql);
            q.AddSqlReturnDefinition(typeof(TransactionType_DAO), "a");
            TransactionType_DAO[] res = q.Execute();

            IEventList<ITransactionType> list = new DAOEventList<TransactionType_DAO, ITransactionType, TransactionType>(res);
            return new ReadOnlyEventList<ITransactionType>(list);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="principal"></param>
        /// <param name="ltTypeKeys">A single or comma separated list of LoanTransactionType Keys</param>
        /// <returns></returns>
        public IReadOnlyEventList<ITransactionType> GetLoanTransactionTypesByKeys(SAHLPrincipal principal, string ltTypeKeys)
        {
            SAHLPrincipalCache spc = SAHLPrincipalCache.GetPrincipalCache(principal);
            string groups = spc.GetCachedRolesAsStringForQuery(true, false);

            string query = UIStatementRepository.GetStatement("Repositories.BulkBatchRepository", "GetLoanTransactionTypesByKeys");
            string sql = String.Format(query, groups, ltTypeKeys);

            SimpleQuery<TransactionType_DAO> q = new SimpleQuery<TransactionType_DAO>(QueryLanguage.Sql, sql);
            q.AddSqlReturnDefinition(typeof(TransactionType_DAO), "a");
            TransactionType_DAO[] res = q.Execute();

            IEventList<ITransactionType> list = new DAOEventList<TransactionType_DAO, ITransactionType, TransactionType>(res);
            return new ReadOnlyEventList<ITransactionType>(list);
        }

        public IReadOnlyEventList<ITransactionType> GetLoanTransactionTypesArrears(SAHLPrincipal principal)
        {
            SAHLPrincipalCache spc = SAHLPrincipalCache.GetPrincipalCache(principal);
            string groups = spc.GetCachedRolesAsStringForQuery(true, false);

            string query = UIStatementRepository.GetStatement("Repositories.BulkBatchRepository", "GetArrearTransactionTypes");
            string sql = String.Format(query, groups);

            SimpleQuery<TransactionType_DAO> q = new SimpleQuery<TransactionType_DAO>(QueryLanguage.Sql, sql);
            q.AddSqlReturnDefinition(typeof(TransactionType_DAO), "a");
            TransactionType_DAO[] res = q.Execute();

            IEventList<ITransactionType> list = new DAOEventList<TransactionType_DAO, ITransactionType, TransactionType>(res);
            return new ReadOnlyEventList<ITransactionType>(list);
        }

        public IBulkBatch GetBulkBatchByKey(int Key)
        {
            return base.GetByKey<IBulkBatch, BulkBatch_DAO>(Key);
        }

        public void DeleteBulkBatchLog(IBulkBatchLog bbl)
        {
            BulkBatchLog_DAO dao = (BulkBatchLog_DAO)(bbl as IDAOObject).GetDAOObject();
            dao.DeleteAndFlush();

            if (ValidationHelper.PrincipalHasValidationErrors())
                throw new DomainValidationException();
        }

        public void DeleteBatchTransaction(IBatchTransaction bt)
        {
            BatchTransaction_DAO dao = (BatchTransaction_DAO)(bt as IDAOObject).GetDAOObject();
            dao.DeleteAndFlush();

            if (ValidationHelper.PrincipalHasValidationErrors())
                throw new DomainValidationException();
        }

        public void DeleteBulkBatchParameter(IBulkBatchParameter bbp)
        {
            BulkBatchParameter_DAO dao = (BulkBatchParameter_DAO)(bbp as IDAOObject).GetDAOObject();
            dao.DeleteAndFlush();

            if (ValidationHelper.PrincipalHasValidationErrors())
                throw new DomainValidationException();
        }

        public void DeleteBulkBatch(IBulkBatch bb)
        {
            BulkBatch_DAO dao = (BulkBatch_DAO)(bb as IDAOObject).GetDAOObject();
            dao.DeleteAndFlush();

            if (ValidationHelper.PrincipalHasValidationErrors())
                throw new DomainValidationException();
        }

        public void DeleteBulkBatch(int BulkBatchKey)
        {
            BulkBatch_DAO dao = BulkBatch_DAO.Find(BulkBatchKey);
            dao.DeleteAndFlush();

            if (ValidationHelper.PrincipalHasValidationErrors())
                throw new DomainValidationException();
        }
    }
}