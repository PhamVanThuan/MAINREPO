<?xml version="1.0"?>
<doc>
    <assembly>
        <name>StructureMap</name>
    </assembly>
    <members>
        <member name="T:StructureMap.IContainer">
            <summary>
            The main "container" object that implements the Service Locator pattern
            </summary>
        </member>
        <member name="M:StructureMap.IContainer.GetInstance(System.Type,System.String)">
            <summary>
            Creates or finds the named instance of the pluginType
            </summary>
            <param name="pluginType"></param>
            <param name="instanceKey"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.IContainer.GetInstance(System.Type)">
            <summary>
            Creates or finds the default instance of the pluginType
            </summary>
            <param name="pluginType"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.IContainer.GetInstance(System.Type,StructureMap.Pipeline.Instance)">
            <summary>
            Creates a new instance of the requested type using the supplied Instance.  Mostly used internally
            </summary>
            <param name="pluginType"></param>
            <param name="instance"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.IContainer.GetInstance``1(System.String)">
            <summary>
            Creates or finds the named instance of T
            </summary>
            <typeparam name="T"></typeparam>
            <param name="instanceKey"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.IContainer.GetInstance``1">
            <summary>
            Creates or finds the default instance of type T
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.IContainer.GetInstance``1(StructureMap.Pipeline.Instance)">
            <summary>
            Creates a new instance of the requested type T using the supplied Instance.  Mostly used internally
            </summary>
            <param name="instance"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.IContainer.GetAllInstances``1">
            <summary>
            Creates or resolves all registered instances of type T
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.IContainer.GetAllInstances(System.Type)">
            <summary>
            Creates or resolves all registered instances of the pluginType
            </summary>
            <param name="pluginType"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.IContainer.TryGetInstance(System.Type,System.String)">
            <summary>
            Creates or finds the named instance of the pluginType. Returns null if the named instance is not known to the container.
            </summary>
            <param name="pluginType"></param>
            <param name="instanceKey"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.IContainer.TryGetInstance(System.Type)">
            <summary>
            Creates or finds the default instance of the pluginType. Returns null if the pluginType is not known to the container.
            </summary>
            <param name="pluginType"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.IContainer.TryGetInstance``1">
            <summary>
            Creates or finds the default instance of type T. Returns the default value of T if it is not known to the container.
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.IContainer.TryGetInstance``1(System.String)">
            <summary>
            Creates or finds the named instance of type T. Returns the default value of T if the named instance is not known to the container.
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.IContainer.Configure(System.Action{StructureMap.ConfigurationExpression})">
            <summary>
            Used to add additional configuration to a Container *after* the initialization.
            </summary>
            <param name="configure"></param>
        </member>
        <member name="M:StructureMap.IContainer.Inject``1(``0)">
            <summary>
            Injects the given object into a Container as the default for the designated
            TPluginType.  Mostly used for temporarily setting up return values of the Container
            to introduce mocks or stubs during automated testing scenarios
            </summary>
            <typeparam name="TPluginType"></typeparam>
            <param name="instance"></param>
        </member>
        <member name="M:StructureMap.IContainer.Inject(System.Type,System.Object)">
            <summary>
            Injects the given object into a Container as the default for the designated
            pluginType.  Mostly used for temporarily setting up return values of the Container
            to introduce mocks or stubs during automated testing scenarios
            </summary>
            <param name="pluginType"></param>
            <param name="object"></param>
        </member>
        <member name="M:StructureMap.IContainer.GetProfile(System.String)">
            <summary>
            Gets a new child container for the named profile using that profile's defaults with
            fallback to the original parent
            </summary>
            <param name="profileName"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.IContainer.WhatDoIHave">
            <summary>
            Returns a report detailing the complete configuration of all PluginTypes and Instances
            </summary>
            <returns></returns>
        </member>
        <member name="M:StructureMap.IContainer.AssertConfigurationIsValid">
            <summary>
            Use with caution!  Does a full environment test of the configuration of this container.  Will try to create every configured
            instance and afterward calls any methods marked with the [ValidationMethod] attribute
            </summary>
        </member>
        <member name="M:StructureMap.IContainer.GetAllInstances``1(StructureMap.Pipeline.ExplicitArguments)">
            <summary>
            Gets all configured instances of type T using explicitly configured arguments from the "args"
            </summary>
            <typeparam name="T"></typeparam>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.IContainer.GetAllInstances(System.Type,StructureMap.Pipeline.ExplicitArguments)">
            <summary>
            Gets the default instance of type T using the explicitly configured arguments from the "args"
            </summary>
            <param name="type"></param>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.IContainer.With``1(``0)">
            <summary>
            Starts a request for an instance or instances with explicitly configured arguments.  Specifies that any dependency
            of type T should be "arg"
            </summary>
            <typeparam name="T"></typeparam>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.IContainer.With(System.String)">
            <summary>
            Starts a request for an instance or instances with explicitly configured arguments.  Specifies that any dependency or primitive argument
            with the designated name should be the next value.
            </summary>
            <param name="argName"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.IContainer.GetInstance(System.Type,StructureMap.Pipeline.ExplicitArguments)">
            <summary>
            Gets the default instance of the pluginType using the explicitly configured arguments from the "args"
            </summary>
            <param name="pluginType"></param>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.IContainer.EjectAllInstancesOf``1">
            <summary>
            Removes all configured instances of type T from the Container.  Use with caution!
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:StructureMap.IContainer.BuildUp(System.Object)">
            <summary>
            The "BuildUp" method takes in an already constructed object
            and uses Setter Injection to push in configured dependencies
            of that object
            </summary>
            <param name="target"></param>
        </member>
        <member name="M:StructureMap.IContainer.ForGenericType(System.Type)">
            <summary>
            Convenience method to request an object using an Open Generic
            Type and its parameter Types
            </summary>
            <param name="templateType"></param>
            <returns></returns>
            <example>
            IFlattener flattener1 = container.ForGenericType(typeof (IFlattener&lt;&gt;))
                .WithParameters(typeof (Address)).GetInstanceAs&lt;IFlattener&gt;();
            </example>
        </member>
        <member name="M:StructureMap.IContainer.GetInstance``1(StructureMap.Pipeline.ExplicitArguments,System.String)">
            <summary>
            Gets the named instance of the pluginType using the explicitly configured arguments from the "args"
            </summary>
            <typeparam name="T"></typeparam>
            <param name="args"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.IContainer.With(System.Type,System.Object)">
            <summary>
            Starts a request for an instance or instances with explicitly configured arguments.  Specifies that any dependency
            of type T should be "arg"
            </summary>
            <param name="pluginType"></param>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:StructureMap.IContainer.ForObject(System.Object)" -->
        <member name="M:StructureMap.IContainer.GetNestedContainer">
            <summary>
            Starts a "Nested" Container for atomic, isolated access
            </summary>
            <returns></returns>
        </member>
        <member name="M:StructureMap.IContainer.GetNestedContainer(System.String)">
            <summary>
            Starts a new "Nested" Container for atomic, isolated service location.  Opens 
            </summary>
            <param name="profileName"></param>
            <returns></returns>
        </member>
        <member name="P:StructureMap.IContainer.Model">
            <summary>
            Provides queryable access to the configured PluginType's and Instances of this Container
            </summary>
        </member>
        <member name="P:StructureMap.IContainer.Name">
            <summary>
            The name of the container. By default this is set to 
            a random Guid. This is a convience property to 
            assist with debugging. Feel free to set to anything,
            as this is not used in any logic.
            </summary>
        </member>
        <member name="M:StructureMap.Container.#ctor(StructureMap.Graph.PluginGraph)">
            <summary>
                Constructor to create an Container
            </summary>
            <param name="pluginGraph">
                PluginGraph containing the instance and type definitions
                for the Container
            </param>
        </member>
        <member name="M:StructureMap.Container.GetInstance``1(System.String)">
            <summary>
                Creates or finds the named instance of T
            </summary>
            <typeparam name="T"></typeparam>
            <param name="instanceKey"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Container.GetInstance``1(StructureMap.Pipeline.Instance)">
            <summary>
                Creates a new instance of the requested type T using the supplied Instance.  Mostly used internally
            </summary>
            <param name="instance"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Container.GetInstance``1(StructureMap.Pipeline.ExplicitArguments)">
            <summary>
                Gets the default instance of the pluginType using the explicitly configured arguments from the "args"
            </summary>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Container.GetInstance(System.Type,StructureMap.Pipeline.ExplicitArguments)">
            <summary>
                Gets the default instance of the pluginType using the explicitly configured arguments from the "args"
            </summary>
            <param name="pluginType"></param>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Container.GetAllInstances(System.Type,StructureMap.Pipeline.ExplicitArguments)">
            <summary>
                Gets all configured instances of type T using explicitly configured arguments from the "args"
            </summary>
            <param name="type"></param>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Container.GetInstance``1">
            <summary>
                Creates or finds the default instance of type T
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Container.GetAllInstances``1">
            <summary>
                Creates or resolves all registered instances of type T
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Container.GetInstance(System.Type,System.String)">
            <summary>
                Creates or finds the named instance of the pluginType
            </summary>
            <param name="pluginType"></param>
            <param name="instanceKey"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Container.TryGetInstance(System.Type,System.String)">
            <summary>
                Creates or finds the named instance of the pluginType. Returns null if the named instance is not known to the container.
            </summary>
            <param name="pluginType"></param>
            <param name="instanceKey"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Container.TryGetInstance(System.Type)">
            <summary>
                Creates or finds the default instance of the pluginType. Returns null if the pluginType is not known to the container.
            </summary>
            <param name="pluginType"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Container.TryGetInstance``1">
            <summary>
                Creates or finds the default instance of type T. Returns the default value of T if it is not known to the container.
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Container.BuildUp(System.Object)">
            <summary>
                The "BuildUp" method takes in an already constructed object
                and uses Setter Injection to push in configured dependencies
                of that object
            </summary>
            <param name="target"></param>
        </member>
        <member name="M:StructureMap.Container.TryGetInstance``1(System.String)">
            <summary>
                Creates or finds the named instance of type T. Returns the default value of T if the named instance is not known to the container.
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Container.GetInstance(System.Type)">
            <summary>
                Creates or finds the default instance of the pluginType
            </summary>
            <param name="pluginType"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Container.GetInstance(System.Type,StructureMap.Pipeline.Instance)">
            <summary>
                Creates a new instance of the requested type using the supplied Instance.  Mostly used internally
            </summary>
            <param name="pluginType"></param>
            <param name="instance"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Container.GetAllInstances(System.Type)">
            <summary>
                Creates or resolves all registered instances of the pluginType
            </summary>
            <param name="pluginType"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Container.Configure(System.Action{StructureMap.ConfigurationExpression})">
            <summary>
                Used to add additional configuration to a Container *after* the initialization.
            </summary>
            <param name="configure"></param>
        </member>
        <member name="M:StructureMap.Container.WhatDoIHave">
            <summary>
                Returns a report detailing the complete configuration of all PluginTypes and Instances
            </summary>
        </member>
        <member name="M:StructureMap.Container.With``1(``0)">
            <summary>
                Starts a request for an instance or instances with explicitly configured arguments.  Specifies that any dependency
                of type T should be "arg"
            </summary>
            <typeparam name="T"></typeparam>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Container.With(System.Type,System.Object)">
            <summary>
                Starts a request for an instance or instances with explicitly configured arguments.  Specifies that any dependency
                of type T should be "arg"
            </summary>
            <param name="pluginType"></param>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Container.With(System.String)">
            <summary>
                Starts a request for an instance or instances with explicitly configured arguments.  Specifies that any dependency or primitive argument
                with the designated name should be the next value.
            </summary>
            <param name="argName"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Container.AssertConfigurationIsValid">
            <summary>
                Use with caution!  Does a full environment test of the configuration of this container.  Will try to create every configured
                instance and afterward calls any methods marked with the [ValidationMethod] attribute
            </summary>
        </member>
        <member name="M:StructureMap.Container.EjectAllInstancesOf``1">
            <summary>
                Removes all configured instances of type T from the Container.  Use with caution!
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:StructureMap.Container.ForGenericType(System.Type)">
            <summary>
                Convenience method to request an object using an Open Generic
                Type and its parameter Types
            </summary>
            <param name="templateType"></param>
            <returns></returns>
            <example>
                IFlattener flattener1 = container.ForGenericType(typeof (IFlattener&lt;&gt;))
                .WithParameters(typeof (Address)).GetInstanceAs&lt;IFlattener&gt;();
            </example>
        </member>
        <!-- Badly formed XML comment ignored for member "M:StructureMap.Container.ForObject(System.Object)" -->
        <member name="M:StructureMap.Container.GetNestedContainer">
            <summary>
                Starts a "Nested" Container for atomic, isolated access
            </summary>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Container.GetNestedContainer(System.String)">
            <summary>
                Starts a new "Nested" Container for atomic, isolated service location.  Opens
            </summary>
            <param name="profileName"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Container.Inject``1(``0)">
            <summary>
                Injects the given object into a Container as the default for the designated
                TPluginType.  Mostly used for temporarily setting up return values of the Container
                to introduce mocks or stubs during automated testing scenarios
            </summary>
            <typeparam name="TPluginType"></typeparam>
            <param name="instance"></param>
        </member>
        <member name="M:StructureMap.Container.Inject(System.Type,System.Object)">
            <summary>
                Injects the given object into a Container as the default for the designated
                pluginType.  Mostly used for temporarily setting up return values of the Container
                to introduce mocks or stubs during automated testing scenarios
            </summary>
        </member>
        <member name="M:StructureMap.Container.Inject(System.Type,StructureMap.Pipeline.Instance)">
            <summary>
                Sets the default instance for the PluginType
            </summary>
            <param name="pluginType"></param>
            <param name="instance"></param>
        </member>
        <member name="P:StructureMap.Container.Model">
            <summary>
                Provides queryable access to the configured PluginType's and Instances of this Container
            </summary>
        </member>
        <member name="P:StructureMap.Container.Name">
            <summary>
                The name of the container. By default this is set to
                a random Guid. This is a convience property to
                assist with debugging. Feel free to set to anything,
                as this is not used in any logic.
            </summary>
        </member>
        <member name="M:StructureMap.AutoMocking.IAutoMocker`1.PartialMockTheClassUnderTest">
            <summary>
                Calling this method will immediately create a "Partial" mock
                for the ClassUnderTest using the "Greediest" constructor.
            </summary>
        </member>
        <member name="M:StructureMap.AutoMocking.IAutoMocker`1.Get``1">
            <summary>
                Gets the mock object for type T that would be injected into the constructor function
                of the ClassUnderTest
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.AutoMocking.IAutoMocker`1.Inject(System.Type,System.Object)">
            <summary>
                Method to specify the exact object that will be used for
                "pluginType."  Useful for stub objects and/or static mocks
            </summary>
            <param name="pluginType"></param>
            <param name="stub"></param>
        </member>
        <member name="M:StructureMap.AutoMocking.IAutoMocker`1.Inject``1(``0)">
            <summary>
                Method to specify the exact object that will be used for
                "pluginType."  Useful for stub objects and/or static mocks
            </summary>
            <typeparam name="T"></typeparam>
            <param name="target"></param>
        </member>
        <member name="M:StructureMap.AutoMocking.IAutoMocker`1.AddAdditionalMockFor``1">
            <summary>
                Adds an additional mock object for a given T
                Useful for array arguments to the ClassUnderTest
                object
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.AutoMocking.IAutoMocker`1.UseConcreteClassFor``1">
            <summary>
                So that Aaron Jensen can use his concrete HubService object
                Construct whatever T is with all mocks, and make sure that the
                ClassUnderTest gets built with a concrete T
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:StructureMap.AutoMocking.IAutoMocker`1.CreateMockArrayFor``1(System.Int32)">
            <summary>
                Creates, returns, and registers an array of mock objects for type T.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.AutoMocking.IAutoMocker`1.InjectArray``1(``0[])">
            <summary>
                Allows you to "inject" an array of known objects for an
                argument of type T[] in the ClassUnderTest
            </summary>
            <typeparam name="T"></typeparam>
            <param name="stubs"></param>
        </member>
        <member name="P:StructureMap.AutoMocking.IAutoMocker`1.ClassUnderTest">
            <summary>
                Gets an instance of the ClassUnderTest with mock objects (or stubs) pushed in for all of its dependencies
            </summary>
        </member>
        <member name="P:StructureMap.AutoMocking.IAutoMocker`1.Container">
            <summary>
                Accesses the underlying AutoMockedContainer
            </summary>
        </member>
        <member name="T:StructureMap.AutoMocking.AutoMocker`1">
            <summary>
                The Auto Mocking Container for StructureMap
            </summary>
            <typeparam name="TTargetClass"></typeparam>
        </member>
        <member name="M:StructureMap.AutoMocking.AutoMocker`1.PartialMockTheClassUnderTest">
            <summary>
                Calling this method will immediately create a "Partial" mock
                for the ClassUnderTest using the "Greediest" constructor.
            </summary>
        </member>
        <member name="M:StructureMap.AutoMocking.AutoMocker`1.Get``1">
            <summary>
                Gets the mock object for type T that would be injected into the constructor function
                of the ClassUnderTest
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.AutoMocking.AutoMocker`1.Inject(System.Type,System.Object)">
            <summary>
                Method to specify the exact object that will be used for
                "pluginType."  Useful for stub objects and/or static mocks
            </summary>
            <param name="pluginType"></param>
            <param name="stub"></param>
        </member>
        <member name="M:StructureMap.AutoMocking.AutoMocker`1.Inject``1(``0)">
            <summary>
                Method to specify the exact object that will be used for
                "pluginType."  Useful for stub objects and/or static mocks
            </summary>
            <typeparam name="T"></typeparam>
            <param name="target"></param>
        </member>
        <member name="M:StructureMap.AutoMocking.AutoMocker`1.AddAdditionalMockFor``1">
            <summary>
                Adds an additional mock object for a given T
                Useful for array arguments to the ClassUnderTest
                object
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.AutoMocking.AutoMocker`1.UseConcreteClassFor``1">
            <summary>
                So that Aaron Jensen can use his concrete HubService object
                Construct whatever T is with all mocks, and make sure that the
                ClassUnderTest gets built with a concrete T
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:StructureMap.AutoMocking.AutoMocker`1.CreateMockArrayFor``1(System.Int32)">
            <summary>
                Creates, returns, and registers an array of mock objects for type T.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.AutoMocking.AutoMocker`1.InjectArray``1(``0[])">
            <summary>
                Allows you to "inject" an array of known objects for an
                argument of type T[] in the ClassUnderTest
            </summary>
            <typeparam name="T"></typeparam>
            <param name="stubs"></param>
        </member>
        <member name="P:StructureMap.AutoMocking.AutoMocker`1.ClassUnderTest">
            <summary>
                Gets an instance of the ClassUnderTest with mock objects (or stubs) pushed in for all of its dependencies
            </summary>
        </member>
        <member name="P:StructureMap.AutoMocking.AutoMocker`1.Container">
            <summary>
                Accesses the underlying AutoMockedContainer
            </summary>
        </member>
        <member name="T:StructureMap.Building.TransientStep">
            <summary>
            Wraps with direct access to the IContext.Transient stuff
            </summary>
        </member>
        <member name="M:StructureMap.IContext.BuildUp(System.Object)">
            <summary>
            The "BuildUp" method takes in an already constructed object
            and uses Setter Injection to push in configured dependencies
            of that object
            </summary>
            <param name="target"></param>
        </member>
        <member name="M:StructureMap.IContext.GetInstance``1">
            <summary>
            Get the object of type T that is valid for this build session.
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.IContext.GetInstance``1(System.String)">
            <summary>
            Get the object of type T that is valid for this build session by name.
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.IContext.GetInstance(System.Type,System.String)">
            <summary>
            Creates or finds the named instance of the pluginType
            </summary>
            <param name="pluginType"></param>
            <param name="instanceKey"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.IContext.TryGetInstance``1">
            <summary>
            Same as GetInstance, but can gracefully return null if 
            the Type does not already exist
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.IContext.TryGetInstance``1(System.String)">
            <summary>
            Same as GetInstance(name), but can gracefully return null if 
            the Type and name does not already exist
            </summary>
            <typeparam name="T"></typeparam>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.IContext.TryGetInstance(System.Type)">
            <summary>
            Creates or finds the default instance of the pluginType. Returns null if the pluginType is not known to the container.
            </summary>
            <param name="pluginType"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.IContext.TryGetInstance(System.Type,System.String)">
            <summary>
            Creates or finds the named instance of the pluginType. Returns null if the named instance is not known to the container.
            </summary>
            <param name="pluginType"></param>
            <param name="instanceKey"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.IContext.All``1">
            <summary>
            Gets all objects in the current object graph that can be cast
            to T that have already been created
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.IContext.GetAllInstances``1">
            <summary>
            Creates/Resolves every configured instance of PlutinType T
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.IContext.GetAllInstances(System.Type)">
            <summary>
            Creates or resolves all registered instances of the pluginType
            </summary>
            <param name="pluginType"></param>
            <returns></returns>
        </member>
        <member name="P:StructureMap.IContext.BuildStack">
            <summary>
            Gets a reference to the <see cref="P:StructureMap.IContext.BuildStack">BuildStack</see> for this build session
            </summary>
        </member>
        <member name="P:StructureMap.IContext.ParentType">
            <summary>
            The concrete type of the immediate parent object in the object graph
            </summary>
        </member>
        <member name="P:StructureMap.IContext.Root">
            <summary>
            Gets the root "frame" of the object request
            </summary>
        </member>
        <member name="P:StructureMap.IContext.RequestedName">
            <summary>
            The requested instance name of the object graph
            </summary>
        </member>
        <member name="M:StructureMap.IPipelineGraph.Root">
            <summary>
                Unwraps a nested container and/or profiles?
            </summary>
            <returns></returns>
        </member>
        <member name="T:StructureMap.Configuration.DSL.Expressions.GenericFamilyExpression">
            <summary>
            Expression Builder that has grammars for defining policies at the 
            PluginType level.  This expression is used for registering 
            open generic types
            </summary>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.GenericFamilyExpression.Use(StructureMap.Pipeline.Instance)">
            <summary>
            Use this configured Instance as is
            </summary>
            <param name="instance"></param>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.GenericFamilyExpression.Use(System.Type)">
            <summary>
            Convenience method that sets the default concrete type of the PluginType.  The "concreteType"
            can only accept types that do not have any primitive constructor arguments.
            StructureMap has to know how to construct all of the constructor argument types.
            </summary>
            <param name="concreteType"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.GenericFamilyExpression.Use(System.Object)">
            <summary>
            Shortcut to add a value by type
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.GenericFamilyExpression.Add(System.Type)">
            <summary>
            Shortcut method to add an additional Instance to this Plugin Type
            as just a Concrete Type.  This will only work if the Concrete Type
            has no primitive constructor or mandatory Setter arguments.
            </summary>
            <param name="concreteType"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.GenericFamilyExpression.Add(System.Object)">
            <summary>
            Configure this type as the supplied value
            </summary>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.GenericFamilyExpression.OnCreationForAll(System.Action{System.Object})">
            <summary>
            Register an Action to run against any object of this PluginType immediately after
            it is created, but before the new object is passed back to the caller
            </summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.GenericFamilyExpression.EnrichAllWith(System.Func{System.Object,System.Object})">
            <summary>
            Register a Func to run against any object of this PluginType immediately after it is created,
            but before the new object is passed back to the caller.  Unlike <see cref="M:StructureMap.Configuration.DSL.Expressions.GenericFamilyExpression.OnCreationForAll(System.Action{System.Object})">OnCreationForAll()</see>,
            EnrichAllWith() gives the the ability to return a different object.  Use this method for runtime AOP
            scenarios or to return a decorator.
            </summary>
            <param name="func"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.GenericFamilyExpression.EnrichAllWith(System.Func{StructureMap.IContext,System.Object,System.Object})">
            <summary>
            Register a Func to run against any object of this PluginType immediately after it is created,
            but before the new object is passed back to the caller.  Unlike <see cref="M:StructureMap.Configuration.DSL.Expressions.GenericFamilyExpression.OnCreationForAll(System.Action{System.Object})">OnCreationForAll()</see>,
            EnrichAllWith() gives the the ability to return a different object.  Use this method for runtime AOP
            scenarios or to return a decorator.
            </summary>
            <param name="func"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.GenericFamilyExpression.LifecycleIs(StructureMap.Pipeline.ILifecycle)">
            <summary>
            Registers an IBuildInterceptor for this Plugin Type that executes before
            any object of this PluginType is created.  IBuildInterceptor's can be
            used to create a custom scope
            </summary>
            <param name="lifecycle"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.GenericFamilyExpression.Singleton">
            <summary>
            Convenience method to mark a PluginFamily as a Singleton
            </summary>
            <returns></returns>
        </member>
        <member name="T:StructureMap.Configuration.IPluginGraphConfiguration">
            <summary>
            Interacts with PluginGraph
            </summary>
        </member>
        <member name="M:StructureMap.Configuration.IPluginGraphConfiguration.Configure(StructureMap.Graph.PluginGraph)">
            <summary>
            Configure an already built <see cref="T:StructureMap.Graph.PluginGraph"/>
            </summary>
        </member>
        <member name="M:StructureMap.Configuration.IPluginGraphConfiguration.Register(StructureMap.PluginGraphBuilder)">
            <summary>
            Registers an PluginGraphBuilder
            </summary>
            <param name="builder"></param>
        </member>
        <member name="M:StructureMap.IExplicitProperty.EqualTo(System.Object)">
            <summary>
            Specify the value of this explicit argument
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.ExplicitArgsExpression.With``1(``0)">
            <summary>
            Pass in additional arguments by type T
            </summary>
            <typeparam name="T"></typeparam>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.ExplicitArgsExpression.With(System.Type,System.Object)">
            <summary>
            Pass in additional arguments by type
            </summary>
            <typeparam name="T"></typeparam>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.ExplicitArgsExpression.With(System.String)">
            <summary>
            Pass in additional arguments by name
            </summary>
            <param name="argName"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.ExplicitArgsExpression.GetInstance``1">
            <summary>
            Gets the default instance of type T using the explicitly configured arguments from the "args"
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.ExplicitArgsExpression.GetInstance``1(System.String)">
            <summary>
            Gets a named instance of type T using the explicitly configured arguments from teh "args"
            </summary>
            <typeparam name="T"></typeparam>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.ExplicitArgsExpression.GetInstance(System.Type)">
            <summary>
            Gets the default instance of the pluginType using the explicitly configured arguments from the "args"
            </summary>
            <returns></returns>
        </member>
        <member name="M:StructureMap.ExplicitArgsExpression.GetAllInstances``1">
            <summary>
            Gets all configured instances of type T using explicitly configured arguments
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Graph.Constructor.GetConstructor(System.Type)">
            <summary>
            Returns the System.Reflection.ConstructorInfo for the PluggedType.  Uses either
            the "greediest" constructor with the most arguments or the constructor function
            marked with the [DefaultConstructor]
            </summary>
            <returns></returns>
        </member>
        <member name="T:StructureMap.Graph.ConfigurableRegistrationConvention">
            <summary>
            Allows built-in registration conventions to be configurable through the assembly scanning DSL
            </summary>
            <remarks>
            Intended for StructureMap internal use only. 
            Custom registration convention instances can be directly configured 
            before being passed to IAssemblyScanner.With(IRegistrationConvention).
            </remarks>
        </member>
        <member name="M:StructureMap.Graph.HasScope.SetScopeTo``1">
            <summary>
            Use InstanceScope for the constants now
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:StructureMap.Graph.IAssemblyScanner.Assembly(System.Reflection.Assembly)">
            <summary>
            Add an Assembly to the scanning operation
            </summary>
            <param name="assembly"></param>
        </member>
        <member name="M:StructureMap.Graph.IAssemblyScanner.Assembly(System.String)">
            <summary>
            Add an Assembly by name to the scanning operation
            </summary>
            <param name="assemblyName"></param>
        </member>
        <member name="M:StructureMap.Graph.IAssemblyScanner.TheCallingAssembly">
            <summary>
            Add the currently executing Assembly to the scanning operation
            </summary>
        </member>
        <member name="M:StructureMap.Graph.IAssemblyScanner.AssemblyContainingType``1">
            <summary>
            Add the Assembly that contains type T to the scanning operation
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:StructureMap.Graph.IAssemblyScanner.AssemblyContainingType(System.Type)">
            <summary>
            Add the Assembly that contains type to the scanning operation
            </summary>
            <param name="type"></param>
        </member>
        <member name="M:StructureMap.Graph.IAssemblyScanner.AssembliesFromPath(System.String)">
            <summary>
            Sweep the designated path and add any Assembly's found in this folder to the
            scanning operation
            </summary>
            <param name="path"></param>
        </member>
        <member name="M:StructureMap.Graph.IAssemblyScanner.AssembliesFromPath(System.String,System.Predicate{System.Reflection.Assembly})">
            <summary>
            Sweep the designated path and add any Assembly's found in this folder to the
            scanning operation.  The assemblyFilter can be used to filter or limit the 
            Assembly's that are picked up.
            </summary>
            <param name="path"></param>
            <param name="assemblyFilter"></param>
        </member>
        <member name="M:StructureMap.Graph.IAssemblyScanner.AssembliesFromApplicationBaseDirectory">
            <summary>
            Sweep the application base directory of current app domain and add any Assembly's 
            found to the scanning operation.
            </summary>
        </member>
        <member name="M:StructureMap.Graph.IAssemblyScanner.AssembliesFromApplicationBaseDirectory(System.Predicate{System.Reflection.Assembly})">
            <summary>
            Sweep the application base directory of current app domain and add any Assembly's 
            found to the scanning operation. The assemblyFilter can be used to filter or limit the 
            Assembly's that are picked up.
            </summary>
        </member>
        <member name="M:StructureMap.Graph.IAssemblyScanner.LookForRegistries">
            <summary>
            Directs the scanning operation to automatically detect and include any Registry
            classes found in the Assembly's being scanned
            </summary>
        </member>
        <member name="M:StructureMap.Graph.IAssemblyScanner.AddAllTypesOf``1">
            <summary>
            Add all concrete types of the Plugin Type as Instances of Plugin Type
            </summary>
            <typeparam name="TPluginType"></typeparam>
        </member>
        <member name="M:StructureMap.Graph.IAssemblyScanner.AddAllTypesOf(System.Type)">
            <summary>
            Add all concrete types of the Plugin Type as Instances of Plugin Type
            </summary>
            <param name="pluginType"></param>
        </member>
        <member name="M:StructureMap.Graph.IAssemblyScanner.Exclude(System.Func{System.Type,System.Boolean})">
            <summary>
            Exclude types that match the Predicate from being scanned
            </summary>
            <param name="exclude"></param>
        </member>
        <member name="M:StructureMap.Graph.IAssemblyScanner.ExcludeNamespace(System.String)">
            <summary>
            Exclude all types in this nameSpace or its children from the scanning operation
            </summary>
            <param name="nameSpace"></param>
        </member>
        <member name="M:StructureMap.Graph.IAssemblyScanner.ExcludeNamespaceContainingType``1">
            <summary>
            Exclude all types in this nameSpace or its children from the scanning operation
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:StructureMap.Graph.IAssemblyScanner.Include(System.Func{System.Type,System.Boolean})">
            <summary>
            Only include types matching the Predicate in the scanning operation. You can 
            use multiple Include() calls in a single scanning operation
            </summary>
            <param name="predicate"></param>
        </member>
        <member name="M:StructureMap.Graph.IAssemblyScanner.IncludeNamespace(System.String)">
            <summary>
            Only include types from this nameSpace or its children in the scanning operation.  You can 
            use multiple Include() calls in a single scanning operation
            </summary>
            <param name="nameSpace"></param>
        </member>
        <member name="M:StructureMap.Graph.IAssemblyScanner.IncludeNamespaceContainingType``1">
            <summary>
            Only include types from this nameSpace or its children in the scanning operation.  You can 
            use multiple Include() calls in a single scanning operation
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:StructureMap.Graph.IAssemblyScanner.ExcludeType``1">
            <summary>
            Exclude this specific type from the scanning operation
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:StructureMap.Graph.IAssemblyScanner.Convention``1">
            <summary>
            Adds a registration convention to be applied to all the types in this
            logical "scan" operation
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:StructureMap.Graph.IAssemblyScanner.With(StructureMap.Graph.IRegistrationConvention)">
            <summary>
            Adds a registration convention to be applied to all the types in this
            logical "scan" operation
            </summary>
        </member>
        <member name="M:StructureMap.Graph.IAssemblyScanner.WithDefaultConventions">
            <summary>
            Adds the DefaultConventionScanner to the scanning operations.  I.e., a concrete
            class named "Something" that implements "ISomething" will be automatically 
            added to PluginType "ISomething"
            </summary>
        </member>
        <member name="M:StructureMap.Graph.IAssemblyScanner.ConnectImplementationsToTypesClosing(System.Type)">
            <summary>
            Scans for PluginType's and Concrete Types that close the given open generic type
            </summary>
            <example>
            
            </example>
            <param name="openGenericType"></param>
        </member>
        <member name="M:StructureMap.Graph.IAssemblyScanner.RegisterConcreteTypesAgainstTheFirstInterface">
            <summary>
            Automatically registers all concrete types without primitive arguments
            against its first interface, if any
            </summary>
        </member>
        <member name="M:StructureMap.Graph.IAssemblyScanner.SingleImplementationsOfInterface">
            <summary>
            Directs the scanning to automatically register any type that is the single
            implementation of an interface against that interface.
            The filters apply
            </summary>
        </member>
        <member name="M:StructureMap.Graph.AssemblyScanner.WithDefaultConventions">
            <summary>
            Adds the DefaultConventionScanner to the scanning operations.  I.e., a concrete
            class named "Something" that implements "ISomething" will be automatically 
            added to PluginType "ISomething"
            </summary>
        </member>
        <member name="M:StructureMap.Graph.AssemblyScanner.ConnectImplementationsToTypesClosing(System.Type)">
            <summary>
            Scans for PluginType's and Concrete Types that close the given open generic type
            </summary>
            <example>
            
            </example>
            <param name="openGenericType"></param>
        </member>
        <member name="M:StructureMap.Graph.AssemblyScanner.RegisterConcreteTypesAgainstTheFirstInterface">
            <summary>
            Automatically registers all concrete types without primitive arguments
            against its first interface, if any
            </summary>
        </member>
        <member name="M:StructureMap.Graph.AssemblyScanner.SingleImplementationsOfInterface">
            <summary>
            Directs the scanning to automatically register any type that is the single
            implementation of an interface against that interface.
            The filters apply
            </summary>
        </member>
        <member name="M:StructureMap.Graph.IPluginGraph.AddType(System.Type,System.Type)">
            <summary>
              Adds the concreteType as an Instance of the pluginType
            </summary>
            <param name = "pluginType"></param>
            <param name = "concreteType"></param>
        </member>
        <member name="M:StructureMap.Graph.IPluginGraph.AddType(System.Type,System.Type,System.String)">
            <summary>
              Adds the concreteType as an Instance of the pluginType with a name
            </summary>
            <param name = "pluginType"></param>
            <param name = "concreteType"></param>
            <param name = "name"></param>
        </member>
        <member name="T:StructureMap.Interceptors.TypeInterceptor">
            <summary>
            A TypeInterceptor that is only applied if the MatchesType()
            method is true for a given Type
            </summary>
        </member>
        <member name="T:StructureMap.Interceptors.InstanceInterceptor">
            <summary>
            An InstanceInterceptor can be registered on a per-Instance basis
            to act on, or even replace, the object that is created before
            it is passed back to the caller.  This is primarily a hook
            for runtime AOP scenarios.
            </summary>
        </member>
        <member name="M:StructureMap.Interceptors.TypeInterceptor.MatchesType(System.Type)">
            <summary>
            Does this TypeInterceptor apply to the given type?
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Interceptors.MatchedTypeInterceptor.InterceptWith(System.Func{System.Object,System.Object})">
            <summary>
            Specify how objects matching the Type predicate
            will be intercepted
            </summary>
            <param name="interception"></param>
        </member>
        <member name="M:StructureMap.Interceptors.MatchedTypeInterceptor.InterceptWith(System.Func{StructureMap.IContext,System.Object,System.Object})">
            <summary>
            Specify how objects matching the Type predicate
            will be intercepted
            </summary>
            <param name="interception"></param>
        </member>
        <member name="T:StructureMap.Pipeline.ArrayDefinitionExpression`2">
            <summary>
                Expression Builder to help define multiple Instances for an Array dependency
            </summary>
            <typeparam name="TElementType"></typeparam>
            <typeparam name="TInstance"></typeparam>
        </member>
        <member name="M:StructureMap.Pipeline.ArrayDefinitionExpression`2.Contains(System.Action{StructureMap.Configuration.DSL.Expressions.IInstanceExpression{`1}})">
            <summary>
                Nested Closure that allows you to add an unlimited number of child Instances
            </summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.ArrayDefinitionExpression`2.Contains(StructureMap.Pipeline.Instance[])">
            <summary>
                Specify an array of Instance objects directly for an Array dependency
            </summary>
            <param name="children"></param>
            <returns></returns>
        </member>
        <member name="T:StructureMap.Pipeline.ConfiguredInstance">
            <summary>
            An Instance class that builds objects by calling a constructor function on a concrete type
            and filling setter properties.  ConfiguredInstance should only be used for open generic types.
            Favor <see cref="T:StructureMap.Pipeline.SmartInstance`1">SmartInstance{T}</see> for all other usages.
            </summary>
        </member>
        <member name="M:StructureMap.Pipeline.ConstructorInstance`1.Ctor``1">
            <summary>
                Inline definition of a constructor dependency.  Select the constructor argument by type.  Do not
                use this method if there is more than one constructor arguments of the same type
            </summary>
            <typeparam name="TCtorType"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.ConstructorInstance`1.Ctor``1(System.String)">
            <summary>
                Inline definition of a constructor dependency.  Select the constructor argument by type and constructor name.
                Use this method if there is more than one constructor arguments of the same type
            </summary>
            <typeparam name="TCtorType"></typeparam>
            <param name="constructorArg"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.ConstructorInstance`1.Setter``1">
            <summary>
                Inline definition of a setter dependency.  Only use this method if there
                is only a single property of the TSetterType
            </summary>
            <typeparam name="TSetterType"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.ConstructorInstance`1.Setter``1(System.String)">
            <summary>
                Inline definition of a setter dependency.  Only use this method if there
                is only a single property of the TSetterType
            </summary>
            <typeparam name="TSetterType"></typeparam>
            <param name="setterName">The name of the property</param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.ConstructorInstance`1.EnumerableOf``1">
            <summary>
                Inline definition of a dependency on an Array of the CHILD type.  I.e. CHILD[].
                This method can be used for either constructor arguments or setter properties
            </summary>
            <typeparam name="TChild"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.ConstructorInstance`1.EnumerableOf``1(System.String)">
            <summary>
                Inline definition of a dependency on an Array of the CHILD type and the specified setter property or constructor argument name.  I.e. CHILD[].
                This method can be used for either constructor arguments or setter properties
            </summary>
            <typeparam name="TChild"></typeparam>
            <param name="ctorOrPropertyName"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.ConfiguredInstance.OnCreation``1(System.Action{``0})">
            <summary>
            Register an Action to perform on the object created by this Instance
            before it is returned to the caller
            </summary>
            <typeparam name="T"></typeparam>
            <param name="handler"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.ConfiguredInstance.OnCreation``1(System.Action{StructureMap.IContext,``0})">
            <summary>
            Register an Action to perform on the object created by this Instance
            before it is returned to the caller
            </summary>
            <typeparam name="T"></typeparam>
            <param name="handler"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.ConfiguredInstance.EnrichWith``1(StructureMap.Interceptors.EnrichmentHandler{``0})">
            <summary>
            Register a Func to potentially enrich or substitute for the object
            created by this Instance before it is returned to the caller
            </summary>
            <param name="handler"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.ConfiguredInstance.EnrichWith``1(StructureMap.Interceptors.ContextEnrichmentHandler{``0})">
            <summary>
            Register a Func to potentially enrich or substitute for the object
            created by this Instance before it is returned to the caller
            </summary>
            <param name="handler"></param>
            <returns></returns>
        </member>
        <member name="T:StructureMap.Pipeline.DependencyExpression`2">
            <summary>
            Expression Builder that helps to define child dependencies inline 
            </summary>
            <typeparam name="TChild"></typeparam>
            <typeparam name="TInstance"></typeparam>
        </member>
        <member name="M:StructureMap.Pipeline.DependencyExpression`2.EqualToAppSetting(System.String)">
            <summary>
            Sets the value of the constructor argument to the key/value in the 
            AppSettings
            </summary>
            <param name="appSettingKey">The key in appSettings for the value to use.</param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.DependencyExpression`2.EqualToAppSetting(System.String,System.String)">
            <summary>
            Sets the value of the constructor argument to the key/value in the 
            AppSettings when it exists. Otherwise uses the provided default value.
            </summary>
            <param name="appSettingKey">The key in appSettings for the value to use.</param>
            <param name="defaultValue">The value to use if an entry for <paramref name="appSettingKey"/> does not exist in the appSettings section.</param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.DependencyExpression`2.Is(System.Action{StructureMap.Configuration.DSL.Expressions.IInstanceExpression{`1}})">
            <summary>
            Nested Closure to define a child dependency inline
            </summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.DependencyExpression`2.Is(StructureMap.Pipeline.Instance)">
            <summary>
            Shortcut to set an inline dependency to an Instance
            </summary>
            <param name="instance"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.DependencyExpression`2.Is(`1)">
            <summary>
            Shortcut to set an inline dependency to a designated object
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.DependencyExpression`2.IsTheDefault">
            <summary>
            Set an Inline dependency to the Default Instance of the Property type
            Used mostly to force an optional Setter property to be filled by
            StructureMap
            </summary>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.DependencyExpression`2.IsNamedInstance(System.String)">
            <summary>
            Set the inline dependency to the named instance of the property type
            Used mostly to force an optional Setter property to be filled by
            StructureMap        /// </summary>
            <param name="instanceKey"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.DependencyExpression`2.Is``1">
            <summary>
            Shortcut method to define a child dependency inline
            </summary>
            <typeparam name="TConcreteType"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.DependencyExpression`2.Is``1(System.Action{StructureMap.Pipeline.SmartInstance{``0}})">
            <summary>
            Shortcut method to define a child dependency inline and configure
            the child dependency
            </summary>
            <typeparam name="TConcreteType"></typeparam>
            <returns></returns>
        </member>
        <member name="T:StructureMap.Pipeline.ExpressedInstance`1">
            <summary>
                Base class for many of the Instance subclasses to support
                method chaining in the Registry DSL for common options
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:StructureMap.Pipeline.ExpressedInstance`1.Named(System.String)">
            <summary>
                Set the name of this Instance
            </summary>
            <param name="instanceKey"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.ExpressedInstance`1.OnCreation``1(System.Action{``0})">
            <summary>
                Register an Action to perform on the object created by this Instance
                before it is returned to the caller
            </summary>
            <typeparam name="THandler"></typeparam>
            <param name="handler"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.ExpressedInstance`1.EnrichWith``1(StructureMap.Interceptors.EnrichmentHandler{``0})">
            <summary>
                Register a Func to potentially enrich or substitute for the object
                created by this Instance before it is returned to the caller
            </summary>
            <typeparam name="THandler"></typeparam>
            <param name="handler"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.ExpressedInstance`1.EnrichWith``1(StructureMap.Interceptors.ContextEnrichmentHandler{``0})">
            <summary>
                Register a Func to potentially enrich or substitute for the object
                created by this Instance before it is returned to the caller
            </summary>
            <typeparam name="THandler"></typeparam>
            <param name="handler"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.ExpressedInstance`1.InterceptWith(StructureMap.Interceptors.InstanceInterceptor)">
            <summary>
                Register an <see cref="T:StructureMap.Interceptors.InstanceInterceptor">InstanceInterceptor</see> with this Instance
            </summary>
            <param name="interceptor"></param>
            <returns></returns>
        </member>
        <member name="T:StructureMap.DefaultConstructorAttribute">
            <summary>
            Used to override the constructor of a class to be used by StructureMap to create
            a Pluggable object
            </summary>
        </member>
        <member name="M:StructureMap.DefaultConstructorAttribute.GetConstructor(System.Type)">
            <summary>
            Examines a System.Type object and determines the ConstructorInfo to use in creating
            instances of the Type
            </summary>
            <param name="ExportedType"></param>
            <returns></returns>
        </member>
        <member name="T:StructureMap.Attributes.SetterPropertyAttribute">
            <summary>
            Marks a Property in a Pluggable class as filled by setter injection 
            </summary>
        </member>
        <member name="T:StructureMap.ValidationMethodAttribute">
            <summary>
            Marks a method with no parameters as a method that validates an instance.  StructureMap
            uses this method to validate the configuration file.  If the method does not throw an
            exception, the object is assumed to be valid.
            </summary>
        </member>
        <member name="M:StructureMap.ValidationMethodAttribute.GetValidationMethods(System.Type)">
            <summary>
            Returns an array of any MethodInfo's on a Type that are marked as ValidationMethod
            </summary>
            <param name="objectType">CLR Type to search for validation methods</param>
            <returns></returns>
        </member>
        <member name="T:StructureMap.Configuration.DSL.Expressions.CreatePluginFamilyExpression`1">
            <summary>
            Expression Builder that has grammars for defining policies at the 
            PluginType level
            </summary>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.CreatePluginFamilyExpression`1.AddInstances(System.Action{StructureMap.Configuration.DSL.Expressions.IInstanceExpression{`0}})">
            <summary>
            Add multiple Instances to this PluginType
            </summary>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.CreatePluginFamilyExpression`1.UseSpecial(System.Action{StructureMap.Configuration.DSL.Expressions.IInstanceExpression{`0}})">
            <summary>
            Access to all of the uncommon Instance types
            </summary>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.CreatePluginFamilyExpression`1.AddSpecial(System.Action{StructureMap.Configuration.DSL.Expressions.IInstanceExpression{`0}})">
            <summary>
            Access to all of the uncommon Instance types
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:StructureMap.Configuration.DSL.Expressions.CreatePluginFamilyExpression`1.Use``1" -->
        <member name="M:StructureMap.Configuration.DSL.Expressions.CreatePluginFamilyExpression`1.Use(System.Func{StructureMap.IContext,`0})">
            <summary>
            Use a lambda using the IContext to construct the default instance of the Plugin type
            
            </summary>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.CreatePluginFamilyExpression`1.Use(System.Func{`0})">
            <summary>
            Use a lambda to construct the default instance of the Plugin type
            </summary>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.CreatePluginFamilyExpression`1.Use(StructureMap.Pipeline.Instance)">
            <summary>
            Makes the supplied instance the default Instance for 
            TPluginType
            </summary>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.CreatePluginFamilyExpression`1.Use(`0)">
            <summary>
            Shorthand to say TheDefault.IsThis(@object)
            </summary>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.CreatePluginFamilyExpression`1.Use(System.String)">
            <summary>
            Makes the default instance of TPluginType the named
            instance
            </summary>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.CreatePluginFamilyExpression`1.UseIfNone``1">
            <summary>
            Defines a fallback instance in case no default was defined for TPluginType
            </summary>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.CreatePluginFamilyExpression`1.Singleton">
            <summary>
            Convenience method to mark a PluginFamily as a Singleton
            </summary>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.CreatePluginFamilyExpression`1.Transient">
            <summary>
            Convenience method to mark a PluginFamily as a Transient
            </summary>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.CreatePluginFamilyExpression`1.OnCreationForAll(System.Action{`0})">
            <summary>
            Register an Action to run against any object of this PluginType immediately after
            it is created, but before the new object is passed back to the caller
            </summary>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.CreatePluginFamilyExpression`1.OnCreationForAll(System.Action{StructureMap.IContext,`0})">
            <summary>
            Register an Action to run against any object of this PluginType immediately after
            it is created, but before the new object is passed back to the caller
            </summary>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.CreatePluginFamilyExpression`1.InterceptWith(StructureMap.Interceptors.InstanceInterceptor)">
            <summary>
            Adds an Interceptor to only this PluginType
            </summary>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.CreatePluginFamilyExpression`1.EnrichAllWith(StructureMap.Interceptors.EnrichmentHandler{`0})">
            <summary>
            Register a Func to run against any object of this PluginType immediately after it is created,
            but before the new object is passed back to the caller.  Unlike OnCreationForAll(),
            EnrichAllWith() gives the the ability to return a different object.  Use this method for runtime AOP
            scenarios or to return a decorator.
            </summary>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.CreatePluginFamilyExpression`1.EnrichAllWith(StructureMap.Interceptors.ContextEnrichmentHandler{`0})">
            <summary>
            Register a Func to run against any object of this PluginType immediately after it is created,
            but before the new object is passed back to the caller.  Unlike OnCreationForAll(),
            EnrichAllWith() gives the the ability to return a different object.  Use this method for runtime AOP
            scenarios or to return a decorator.
            </summary>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.CreatePluginFamilyExpression`1.LifecycleIs(StructureMap.Pipeline.ILifecycle)">
            <summary>
            Registers an ILifecycle for this Plugin Type that executes before
            any object of this PluginType is created.  ILifecycle's can be
            used to create a custom scope
            </summary>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.CreatePluginFamilyExpression`1.AlwaysUnique">
            <summary>
            Forces StructureMap to always use a unique instance to
            stop the "BuildSession" caching
            </summary>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.CreatePluginFamilyExpression`1.Add(`0)">
            <summary>
            Adds the object to to the TPluginType
            </summary>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.CreatePluginFamilyExpression`1.Add(System.Func{StructureMap.IContext,`0})">
            <summary>
            Add an Instance to this type created by a Lambda
            </summary>
        </member>
        <member name="T:StructureMap.Configuration.DSL.Registry">
            <summary>
            A Registry class provides methods and grammars for configuring a Container or ObjectFactory.
            Using a Registry subclass is the recommended way of configuring a StructureMap Container.
            </summary>
            <example>
            public class MyRegistry : Registry
            {
                public MyRegistry()
                {
                    ForRequestedType(typeof(IService)).TheDefaultIsConcreteType(typeof(Service));
                }
            }
            </example>
        </member>
        <member name="M:StructureMap.Configuration.DSL.IRegistry.AddType(System.Type,System.Type)">
            <summary>
            Adds the concreteType as an Instance of the pluginType
            </summary>
            <param name="pluginType"></param>
            <param name="concreteType"></param>
        </member>
        <member name="M:StructureMap.Configuration.DSL.IRegistry.AddType(System.Type,System.Type,System.String)">
            <summary>
            Adds the concreteType as an Instance of the pluginType with a name
            </summary>
            <param name="pluginType"></param>
            <param name="concreteType"></param>
            <param name="name"></param>
        </member>
        <member name="M:StructureMap.Configuration.DSL.IRegistry.IncludeRegistry``1">
            <summary>
            Imports the configuration from another registry into this registry.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:StructureMap.Configuration.DSL.IRegistry.IncludeRegistry(StructureMap.Configuration.DSL.Registry)">
            <summary>
            Imports the configuration from another registry into this registry.
            </summary>
            <param name="registry"></param>
        </member>
        <member name="M:StructureMap.Configuration.DSL.IRegistry.ForConcreteType``1">
            <summary>
            This method is a shortcut for specifying the default constructor and 
            setter arguments for a ConcreteType.  ForConcreteType is shorthand for:
            For[T]().Use[T].**************
            when the PluginType and ConcreteType are the same Type
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.IRegistry.ForSingletonOf``1">
            <summary>
            Convenience method.  Equivalent of For[PluginType]().AsSingletons()
            </summary>
            <typeparam name="TPluginType"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.IRegistry.Profile(System.String,System.Action{StructureMap.Configuration.DSL.Registry})">
            <summary>
            An alternative way to use CreateProfile that uses ProfileExpression
            as a Nested Closure.  This usage will result in cleaner code for 
            multiple declarations
            </summary>
            <param name="profileName"></param>
            <param name="action"></param>
        </member>
        <member name="M:StructureMap.Configuration.DSL.IRegistry.RegisterInterceptor(StructureMap.Interceptors.TypeInterceptor)">
            <summary>
            Registers a new TypeInterceptor object with the Container
            </summary>
            <param name="interceptor"></param>
        </member>
        <member name="M:StructureMap.Configuration.DSL.IRegistry.IfTypeMatches(System.Predicate{System.Type})">
            <summary>
            Allows you to define a TypeInterceptor inline with Lambdas or anonymous delegates
            </summary>
            <param name="match"></param>
            <returns></returns>
            <example>
            IfTypeMatches( ... ).InterceptWith( o => new ObjectWrapper(o) );
            </example>
        </member>
        <member name="M:StructureMap.Configuration.DSL.IRegistry.Scan(System.Action{StructureMap.Graph.IAssemblyScanner})">
            <summary>
            Designates a policy for scanning assemblies to auto
            register types
            </summary>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.IRegistry.FillAllPropertiesOfType``1">
            <summary>
            Directs StructureMap to always inject dependencies into any and all public Setter properties
            of the type TPluginType.
            </summary>
            <typeparam name="TPluginType"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.IRegistry.SetAllProperties(System.Action{StructureMap.Configuration.DSL.SetterConvention})">
            <summary>
            Creates automatic "policies" for which public setters are considered mandatory
            properties by StructureMap that will be "setter injected" as part of the 
            construction process.
            </summary>
            <param name="action"></param>
        </member>
        <member name="M:StructureMap.Configuration.DSL.IRegistry.Forward``2">
            <summary>
            All requests For the "TO" types will be filled by fetching the "FROM"
            type and casting it to "TO"
            GetInstance(typeof(TO)) basically becomes (TO)GetInstance(typeof(FROM))
            </summary>
            <typeparam name="FROM"></typeparam>
            <typeparam name="TO"></typeparam>
        </member>
        <!-- Badly formed XML comment ignored for member "M:StructureMap.Configuration.DSL.IRegistry.For``1(StructureMap.Pipeline.ILifecycle)" -->
        <member name="M:StructureMap.Configuration.DSL.IRegistry.For(System.Type,StructureMap.Pipeline.ILifecycle)">
            <summary>
            Shorthand for ForRequestedType(pluginType)
            </summary>
            <param name="pluginType"></param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:StructureMap.Configuration.DSL.IRegistry.Redirect``2" -->
        <member name="M:StructureMap.Configuration.DSL.IRegistry.Configure(System.Action{StructureMap.Graph.PluginGraph})">
            <summary>
            Advanced Usage Only!  Skips the Registry and goes right to the inner
            Semantic Model of StructureMap.  Use with care
            </summary>
            <param name="configure"></param>
        </member>
        <member name="M:StructureMap.Configuration.DSL.IRegistry.RegisterPluginGraphConfiguration``1">
            <summary>
            Gives a <see cref="T:StructureMap.Configuration.IPluginGraphConfiguration"/> the possibility to interact with the current <see cref="T:StructureMap.PluginGraphBuilder"/>
            via <see cref="M:StructureMap.Configuration.IPluginGraphConfiguration.Register(StructureMap.PluginGraphBuilder)"/>.
            </summary>
        </member>
        <member name="M:StructureMap.Configuration.DSL.IRegistry.RegisterPluginGraphConfiguration(StructureMap.Configuration.IPluginGraphConfiguration)">
            <summary>
            See <see cref="M:StructureMap.Configuration.DSL.Registry.RegisterPluginGraphConfiguration``1"/>
            </summary>
        </member>
        <member name="M:StructureMap.Configuration.DSL.IRegistry.ConfigurePluginGraph``1">
            <summary>
            Gives a <see cref="T:StructureMap.Configuration.IPluginGraphConfiguration"/> the possibility to interact with the resulting <see cref="T:StructureMap.Graph.PluginGraph"/>,
            i.e. as opposed to <see cref="M:StructureMap.Configuration.DSL.Registry.RegisterPluginGraphConfiguration(StructureMap.Configuration.IPluginGraphConfiguration)"/>, the PluginGraph is built, and the provided
            PluginGraph config obtains access to saig graph.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:StructureMap.Configuration.DSL.IRegistry.ConfigurePluginGraph(StructureMap.Configuration.IPluginGraphConfiguration)">
            <summary>
            <see cref="M:StructureMap.Configuration.DSL.Registry.ConfigurePluginGraph``1"/>
            </summary>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Registry.AddType(System.Type,System.Type)">
            <summary>
            Adds the concreteType as an Instance of the pluginType.  Mostly useful
            for conventions
            </summary>
            <param name="pluginType"></param>
            <param name="concreteType"></param>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Registry.AddType(System.Type,System.Type,System.String)">
            <summary>
            Adds the concreteType as an Instance of the pluginType with a name.  Mostly
            useful for conventions
            </summary>
            <param name="pluginType"></param>
            <param name="concreteType"></param>
            <param name="name"></param>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Registry.IncludeRegistry``1">
            <summary>
            Imports the configuration from another registry into this registry.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Registry.IncludeRegistry(StructureMap.Configuration.DSL.Registry)">
            <summary>
            Imports the configuration from another registry into this registry.
            </summary>
            <param name="registry"></param>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Registry.ForConcreteType``1">
            <summary>
            This method is a shortcut for specifying the default constructor and 
            setter arguments for a ConcreteType.  ForConcreteType is shorthand for:
            For[T]().Use[T].**************
            when the PluginType and ConcreteType are the same Type
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Registry.ForSingletonOf``1">
            <summary>
            Convenience method.  Equivalent of ForRequestedType[PluginType]().Singletons()
            </summary>
            <typeparam name="TPluginType"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Registry.ForSingletonOf(System.Type)">
            <summary>
            Shorthand way of saying For(pluginType).Singleton()
            </summary>
            <param name="pluginType"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Registry.Profile(System.String,System.Action{StructureMap.Configuration.DSL.Registry})">
            <summary>
            An alternative way to use CreateProfile that uses ProfileExpression
            as a Nested Closure.  This usage will result in cleaner code for 
            multiple declarations
            </summary>
            <param name="profileName"></param>
            <param name="action"></param>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Registry.RegisterInterceptor(StructureMap.Interceptors.TypeInterceptor)">
            <summary>
            Registers a new TypeInterceptor object with the Container
            </summary>
            <param name="interceptor"></param>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Registry.IfTypeMatches(System.Predicate{System.Type})">
            <summary>
            Allows you to define a TypeInterceptor inline with Lambdas or anonymous delegates
            </summary>
            <param name="match"></param>
            <returns></returns>
            <example>
            IfTypeMatches( ... ).InterceptWith( o => new ObjectWrapper(o) );
            </example>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Registry.Scan(System.Action{StructureMap.Graph.IAssemblyScanner})">
            <summary>
            Designates a policy for scanning assemblies to auto
            register types
            </summary>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Registry.FillAllPropertiesOfType``1">
            <summary>
            Directs StructureMap to always inject dependencies into any and all public Setter properties
            of the type TPluginType.
            </summary>
            <typeparam name="TPluginType"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Registry.SetAllProperties(System.Action{StructureMap.Configuration.DSL.SetterConvention})">
            <summary>
            Creates automatic "policies" for which public setters are considered mandatory
            properties by StructureMap that will be "setter injected" as part of the 
            construction process.
            </summary>
            <param name="action"></param>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Registry.Forward``2">
            <summary>
            All requests For the "TO" types will be filled by fetching the "FROM"
            type and casting it to "TO"
            GetInstance(typeof(TO)) basically becomes (TO)GetInstance(typeof(FROM))
            </summary>
            <typeparam name="TFrom"></typeparam>
            <typeparam name="TTo"></typeparam>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Registry.For``1(StructureMap.Pipeline.ILifecycle)">
            <summary>
            Expression Builder used to define policies for a PluginType including
            Scoping, the Default Instance, and interception.  BuildInstancesOf()
            and ForRequestedType() are synonyms
            </summary>
            <typeparam name="TPluginType"></typeparam>
            <param name="lifecycle">Optionally specify the instance scoping for this PluginType</param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Registry.For(System.Type,StructureMap.Pipeline.ILifecycle)">
            <summary>
            Expression Builder used to define policies for a PluginType including
            Scoping, the Default Instance, and interception.  This method is specifically
            meant for registering open generic types
            </summary>
            <param name="lifecycle">Optionally specify the instance scoping for this PluginType</param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:StructureMap.Configuration.DSL.Registry.Redirect``2" -->
        <member name="M:StructureMap.Configuration.DSL.Registry.Configure(System.Action{StructureMap.Graph.PluginGraph})">
            <summary>
            Advanced Usage Only!  Skips the Registry and goes right to the inner
            Semantic Model of StructureMap.  Use with care
            </summary>
            <param name="configure"></param>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Registry.RegisterPluginGraphConfiguration``1">
            <summary>
            Gives a <see cref="T:StructureMap.Configuration.IPluginGraphConfiguration"/> the possibility to interact with the current <see cref="T:StructureMap.PluginGraphBuilder"/>
            via <see cref="M:StructureMap.Configuration.IPluginGraphConfiguration.Register(StructureMap.PluginGraphBuilder)"/>.
            </summary>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Registry.RegisterPluginGraphConfiguration(StructureMap.Configuration.IPluginGraphConfiguration)">
            <summary>
            See <see cref="M:StructureMap.Configuration.DSL.Registry.RegisterPluginGraphConfiguration``1"/>
            </summary>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Registry.ConfigurePluginGraph``1">
            <summary>
            Gives a <see cref="T:StructureMap.Configuration.IPluginGraphConfiguration"/> the possibility to interact with the resulting <see cref="T:StructureMap.Graph.PluginGraph"/>,
            i.e. as opposed to <see cref="M:StructureMap.Configuration.DSL.Registry.RegisterPluginGraphConfiguration(StructureMap.Configuration.IPluginGraphConfiguration)"/>, the PluginGraph is built, and the provided
            PluginGraph config obtains access to saig graph.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Registry.ConfigurePluginGraph(StructureMap.Configuration.IPluginGraphConfiguration)">
            <summary>
            <see cref="M:StructureMap.Configuration.DSL.Registry.ConfigurePluginGraph``1"/>
            </summary>
        </member>
        <member name="T:StructureMap.Configuration.DSL.Registry.BuildWithExpression`1">
            <summary>
            Define the constructor and setter arguments for the default T
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:StructureMap.Exceptions.InstancePropertyValueException">
            <summary>
            Thrown by IProperty classes when an invalid value is applied to 
            a property of an InstanceGraph
            </summary>
        </member>
        <member name="T:StructureMap.StructureMapException">
            <summary>
            Main exception for StructureMap.  Use the ErrorCode to aid in troubleshooting
            StructureMap problems
            </summary>
        </member>
        <member name="T:StructureMap.Graph.Plugin">
            <summary>
            Represents a concrete class that can be built by StructureMap as an instance of the parent 
            PluginFamilys PluginType. The properties of a Plugin are the CLR Type of the concrete class, 
            and the human-friendly concrete key that StructureMap will use to identify the Type.
            </summary>
        </member>
        <member name="P:StructureMap.Graph.Plugin.PluggedType">
            <summary>
            The concrete CLR Type represented by the Plugin
            </summary>
        </member>
        <member name="P:StructureMap.Graph.Plugin.Setters">
            <summary>
            Property's that will be filled by setter injection
            </summary>
        </member>
        <member name="T:StructureMap.Graph.PluginFamily">
            <summary>
                Conceptually speaking, a PluginFamily object represents a point of abstraction or variability in
                the system.  A PluginFamily defines a CLR Type that StructureMap can build, and all of the possible
                Plugins implementing the CLR Type.
            </summary>
        </member>
        <member name="M:StructureMap.Graph.PluginFamily.SetDefaultKey(System.String)">
            <summary>
                Primarily for TESTING
            </summary>
            <param name="defaultKey"></param>
        </member>
        <member name="P:StructureMap.Graph.PluginFamily.PluginType">
            <summary>
                The CLR Type that defines the "Plugin" interface for the PluginFamily
            </summary>
        </member>
        <member name="T:StructureMap.Graph.PluginGraph">
            <summary>
              Models the runtime configuration of a StructureMap Container
            </summary>
        </member>
        <member name="M:StructureMap.Graph.PluginGraph.AddType(System.Type,System.Type)">
            <summary>
              Adds the concreteType as an Instance of the pluginType
            </summary>
            <param name = "pluginType"></param>
            <param name = "concreteType"></param>
        </member>
        <member name="M:StructureMap.Graph.PluginGraph.AddType(System.Type,System.Type,System.String)">
            <summary>
              Adds the concreteType as an Instance of the pluginType with a name
            </summary>
            <param name = "pluginType"></param>
            <param name = "concreteType"></param>
            <param name = "name"></param>
        </member>
        <member name="M:StructureMap.Graph.PluginGraph.Configure(System.Action{StructureMap.Configuration.DSL.Registry})">
            <summary>
              Add configuration to a PluginGraph with the Registry DSL
            </summary>
            <param name = "action"></param>
        </member>
        <member name="T:StructureMap.Graph.SetterProperty">
            <summary>
            Represents a PropertyInfo of a Plugin.PluggedType that is filled by Setter Injection
            </summary>
        </member>
        <member name="T:StructureMap.Graph.SetterPropertyCollection">
            <summary>
            Custom collection class for SetterProperty objects
            </summary>
        </member>
        <member name="T:StructureMap.Graph.TypePath">
            <summary>
            Designates a CLR type that is loaded by name.
            </summary>
        </member>
        <member name="T:StructureMap.InstanceMemento">
            <summary>
            GoF Memento representing an Object Instance
            </summary>
        </member>
        <member name="M:StructureMap.InstanceMemento.GetProperty(System.String)">
            <summary>
            Retrieves the named property value as a string
            </summary>
            <param name="Key"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.InstanceMemento.getPropertyValue(System.String)">
            <summary>
            Template method for implementation specific retrieval of the named property
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.InstanceMemento.GetChildMemento(System.String)">
            <summary>
            Returns the named child InstanceMemento
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.InstanceMemento.getChild(System.String)">
            <summary>
            Template method for implementation specific retrieval of the named property
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.InstanceMemento.GetChildrenArray(System.String)">
            <summary>
            This method is made public for testing.  It is not necessary for normal usage.
            </summary>
            <returns></returns>
        </member>
        <member name="P:StructureMap.InstanceMemento.InstanceKey">
            <summary>
            The named key of the object instance represented by the InstanceMemento
            </summary>
        </member>
        <member name="P:StructureMap.InstanceMemento.IsReference">
            <summary>
            Template pattern property specifying whether the InstanceMemento is simply a reference
            to another named instance.  Useful for child objects.
            </summary>
        </member>
        <member name="P:StructureMap.InstanceMemento.ReferenceKey">
            <summary>
            Template pattern property specifying the instance key that the InstanceMemento refers to
            </summary>
        </member>
        <member name="P:StructureMap.InstanceMemento.IsDefault">
            <summary>
            Is the InstanceMemento a reference to the default instance of the Plugin type?
            </summary>
        </member>
        <member name="T:StructureMap.Interceptors.PluginTypeInterceptor">
            <summary>
            A TypeInterceptor that always applies to all Instances of a given Plugin Type
            </summary>
        </member>
        <member name="T:StructureMap.MemoryInstanceMemento">
            <summary>
            An in-memory implementation of InstanceMemento.  
            </summary>
        </member>
        <member name="M:StructureMap.MemoryInstanceMemento.CreateReferencedInstanceMemento(System.String)">
            <summary>
            Creates an instance of MemoryInstanceMemento that represents a reference to another
            instance.
            </summary>
            <param name="referenceKey">The referenced instance key to another instance</param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.MemoryInstanceMemento.CreateDefaultInstanceMemento">
            <summary>
            Creates a MemoryInstanceMemento that represents a reference to the default instance
            of a Plugin type.
            </summary>
            <returns></returns>
        </member>
        <member name="M:StructureMap.MemoryInstanceMemento.#ctor(System.String,System.String)">
            <summary>
            Constructs a MemoryInstanceMemento without properties
            </summary>
            <param name="concreteKey">The concrete key of the Plugin type</param>
            <param name="instanceKey">The identifying instance key</param>
        </member>
        <member name="M:StructureMap.MemoryInstanceMemento.#ctor(System.String,System.String,System.Collections.Specialized.NameValueCollection)">
            <summary>
            Constructs a MemoryInstanceMemento with properties
            </summary>
            <param name="concreteKey">The concrete key of the Plugin type</param>
            <param name="instanceKey">The identifying instance key</param>
            <param name="properties">NameValueCollection of instance properties</param>
        </member>
        <member name="M:StructureMap.MemoryInstanceMemento.SetProperty(System.String,System.String)">
            <summary>
            Sets the value of the named property
            </summary>
            <param name="name"></param>
            <param name="value"></param>
        </member>
        <member name="M:StructureMap.MemoryInstanceMemento.RemoveProperty(System.String)">
            <summary>
            Deletes a named property from the DefaultInstanceMemento
            </summary>
            <param name="Name"></param>
        </member>
        <member name="M:StructureMap.MemoryInstanceMemento.AddChild(System.String,StructureMap.InstanceMemento)">
            <summary>
            Links a child InstanceMemento as a named property
            </summary>
            <param name="name"></param>
            <param name="Memento"></param>
        </member>
        <member name="M:StructureMap.MemoryInstanceMemento.AddChildArray(System.String,StructureMap.InstanceMemento[])">
            <summary>
            Links an array of InstanceMemento's to a named array property
            </summary>
            <param name="name"></param>
            <param name="childMementos"></param>
        </member>
        <member name="M:StructureMap.MemoryInstanceMemento.GetChildrenArray(System.String)">
            <summary>
            See <cref>InstanceMemento</cref>
            </summary>
        </member>
        <member name="P:StructureMap.MemoryInstanceMemento.innerConcreteKey">
            <summary>
            See <cref>InstanceMemento</cref>
            </summary>
        </member>
        <member name="P:StructureMap.MemoryInstanceMemento.innerInstanceKey">
            <summary>
            See <cref>InstanceMemento</cref>
            </summary>
        </member>
        <member name="P:StructureMap.MemoryInstanceMemento.IsReference">
            <summary>
            See <cref>InstanceMemento</cref>
            </summary>
        </member>
        <member name="P:StructureMap.MemoryInstanceMemento.ReferenceKey">
            <summary>
            See <cref>InstanceMemento</cref>
            </summary>
        </member>
        <member name="T:StructureMap.ObjectFactory">
            <summary>
            A convenience "Containment" to hold your container if you are planning to have a single static <see cref="T:StructureMap.IContainer"/> instance in your application.
            
            </summary>
        </member>
        <member name="M:StructureMap.ObjectFactory.Initialize(System.Action{StructureMap.IInitializationExpression})">
            <summary>
            Fire up and initialize a new container. It is accessible through the <see cref="P:StructureMap.ObjectFactory.Container"/> property.
            Some convenience methods are available that route to this container. Passing no action equates to starting the container
            without any configuration. A subsequent call to this method will overwrite the reference that the Objectfactory held to the previous
            <see cref="T:StructureMap.IContainer"/> instance.
            </summary>
        </member>
        <member name="M:StructureMap.ObjectFactory.Configure(System.Action{StructureMap.ConfigurationExpression})">
            <summary>
            Used to add additional configuration to a Container *after* the initialization.
            </summary>
        </member>
        <member name="M:StructureMap.ObjectFactory.GetInstance(System.Type)">
            <summary>
            Creates or finds the default instance of the pluginType
            </summary>
        </member>
        <member name="M:StructureMap.ObjectFactory.GetInstance``1">
            <summary>
            Creates or finds the default instance of type T
            </summary>
        </member>
        <member name="M:StructureMap.ObjectFactory.GetNamedInstance(System.Type,System.String)">
            <summary>
            Creates or finds the named instance of the pluginType
            </summary>
        </member>
        <member name="M:StructureMap.ObjectFactory.GetNamedInstance``1(System.String)">
            <summary>
            Creates or finds the named instance of T
            </summary>
        </member>
        <member name="M:StructureMap.ObjectFactory.GetAllInstances(System.Type)">
            <summary>
            Creates or resolves all registered instances of the pluginType
            </summary>
        </member>
        <member name="M:StructureMap.ObjectFactory.GetAllInstances``1">
            <summary>
            Creates or resolves all registered instances of type T
            </summary>
        </member>
        <member name="M:StructureMap.ObjectFactory.BuildUp(System.Object)">
            <summary>
            The "BuildUp" method takes in an already constructed object
            and uses Setter Injection to push in configured dependencies
            of that object.
            </summary>
        </member>
        <member name="P:StructureMap.ObjectFactory.Container">
            <summary>
            The Container that is kept alive by the ObjectFactory
            </summary>
        </member>
        <member name="T:StructureMap.PluginGraphBuilder">
            <summary>
                Reads configuration XML documents and builds the structures necessary to initialize
                the Container/IInstanceFactory/InstanceBuilder/ObjectInstanceActivator objects
            </summary>
        </member>
        <member name="M:StructureMap.PluginGraphBuilder.Build">
            <summary>
                Reads the configuration information and returns the PluginGraph definition of
                Plugin families and Plugin's
            </summary>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Query.IPluginTypeConfiguration.HasImplementations">
            <summary>
            Simply query to see if there are any implementations registered
            </summary>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Query.IPluginTypeConfiguration.EjectAndRemove(StructureMap.Query.InstanceRef)">
            <summary>
            Ejects any instances of this instance from its lifecycle
            and permanently removes the instance from the container configuration
            </summary>
            <param name="instance"></param>
        </member>
        <member name="M:StructureMap.Query.IPluginTypeConfiguration.EjectAndRemoveAll">
            <summary>
            Eject all instances of this PluginType from the current container,
            but leaves the lifecycle behavior
            </summary>
        </member>
        <member name="P:StructureMap.Query.IPluginTypeConfiguration.Default">
            <summary>
            The "instance" that will be used when Container.GetInstance(PluginType) is called.
            See <see cref="T:StructureMap.Query.InstanceRef">InstanceRef</see> for more information
            </summary>
        </member>
        <member name="P:StructureMap.Query.IPluginTypeConfiguration.Lifecycle">
            <summary>
            The build "policy" for this PluginType.  Used by the WhatDoIHave() diagnostics methods
            </summary>
        </member>
        <member name="P:StructureMap.Query.IPluginTypeConfiguration.Instances">
            <summary>
            All of the <see cref="T:StructureMap.Query.InstanceRef">InstanceRef</see>'s registered
            for this PluginType
            </summary>
        </member>
        <member name="M:StructureMap.Query.IFamily.Eject(StructureMap.Pipeline.Instance)">
            <summary>
            The resulting object from this Instance will be evicted from its
            lifecycle if it has already been created and cached
            </summary>
            <param name="instance"></param>
        </member>
        <member name="M:StructureMap.Query.IFamily.Build(StructureMap.Pipeline.Instance)">
            <summary>
            Builds the object
            </summary>
            <param name="instance"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Query.IFamily.HasBeenCreated(StructureMap.Pipeline.Instance)">
            <summary>
            Queries the lifecycle if it has been created
            </summary>
            <param name="instance"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Util.LightweightCache`2.FillDefault(`0)">
            <summary>
                Guarantees that the Cache has the default value for a given key.
                If it does not already exist, it's created.
            </summary>
            <param name="key"></param>
        </member>
        <member name="M:StructureMap.CloseGenericTypeExpression.StructureMap#OpenGenericTypeSpecificationExpression#As``1">
            <summary>
            specify what type you'd like the service returned as
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.CloseGenericTypeExpression.GetClosedTypeOf(System.Type)">
            <summary>
            Specify the open generic type that should have a single generic parameter
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="T:StructureMap.ConfigurationExpression">
            <summary>
                Used as the argument in the Container.Configure() method to describe
                configuration directives and specify the sources of configuration for
                a Container
            </summary>
        </member>
        <member name="M:StructureMap.ConfigurationExpression.AddRegistry``1">
            <summary>
                Creates and adds a Registry object of type T.
            </summary>
            <typeparam name="T">The Registry Type</typeparam>
        </member>
        <member name="M:StructureMap.ConfigurationExpression.AddRegistry(StructureMap.Configuration.DSL.Registry)">
            <summary>
                Imports all the configuration from a Registry object
            </summary>
            <param name="registry"></param>
        </member>
        <member name="T:StructureMap.Configuration.DSL.Expressions.IsExpression`1">
            <summary>
            Expression Builder to define an Instance
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.IsExpression`1.IsThis(StructureMap.Pipeline.Instance)">
            <summary>
            Register a previously built Instance.  This provides a "catch all"
            method to attach custom Instance objects.  Synonym for Instance()
            </summary>
            <param name="instance"></param>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.IsExpression`1.IsThis(`0)">
            <summary>
            Inject this object directly.  Synonym to Object()
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="P:StructureMap.Configuration.DSL.Expressions.IsExpression`1.Is">
            <summary>
            Gives you full access to all the different ways to specify an "Instance"
            </summary>
        </member>
        <member name="T:StructureMap.Configuration.DSL.Expressions.GenericIsExpression">
            <summary>
            An Expression Builder to define Instances of a PluginType.
            This is mostly used for configuring open generic types
            </summary>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.GenericIsExpression.Is(System.Type)">
            <summary>
            Shortcut to register a Concrete Type as an instance.  This method supports
            method chaining to allow you to add constructor and setter arguments for 
            the concrete type
            </summary>
            <param name="concreteType"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.GenericIsExpression.TheInstanceNamed(System.String)">
            <summary>
            Shortcut to simply use the Instance with the given name
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="T:StructureMap.Configuration.DSL.Expressions.IInstanceExpression`1">
            <summary>
            An Expression Builder that is used throughout the Registry DSL to
            add and define Instances
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.IInstanceExpression`1.Instance(StructureMap.Pipeline.Instance)">
            <summary>
            Register a previously built Instance.  This provides a "catch all"
            method to attach custom Instance objects.  Synonym for IsThis()
            </summary>
            <param name="instance"></param>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.IInstanceExpression`1.Object(`0)">
            <summary>
            Inject this object directly.  Synonym to IsThis()
            </summary>
            <param name="theObject"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.IInstanceExpression`1.Type``1">
            <summary>
            Build the Instance with the constructor function and setter arguments.  Starts
            the definition of a <see cref="T:StructureMap.Pipeline.SmartInstance`1">SmartInstance</see>
            </summary>
            <typeparam name="TPluggedType"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.IInstanceExpression`1.Type(System.Type)">
            <summary>
            Build the Instance with the constructor function and setter arguments.  Use this
            method for open generic types, and favor the generic version of Type()
            for all other types
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.IInstanceExpression`1.ConstructedBy(System.Func{`0})">
            <summary>
            Create an Instance that builds an object by calling a Lambda or
            an anonymous delegate with no arguments
            </summary>
            <param name="func"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.IInstanceExpression`1.ConstructedBy(System.Func{StructureMap.IContext,`0})">
            <summary>
            Create an Instance that builds an object by calling a Lambda or
            an anonymous delegate with the <see cref="T:StructureMap.IContext">IContext</see> representing
            the current object graph.
            </summary>
            <param name="func"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.IInstanceExpression`1.TheInstanceNamed(System.String)">
            <summary>
            Use the Instance of this PluginType with the specified name.  This is
            generally only used while configuring child dependencies within a deep
            object graph
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.IInstanceExpression`1.TheDefault">
            <summary>
            Use the default Instance of this PluginType.  This is
            generally only used while configuring child dependencies within a deep
            object graph
            </summary>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.IInstanceExpression`1.PrototypeOf(`0)">
            <summary>
            Creates an Instance that stores this object of type T,
            and returns a cloned copy of the template.  
            </summary>
            <param name="template"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.IInstanceExpression`1.SerializedCopyOf(`0)">
            <summary>
            Caches template as a serialized byte stream.  Uses deserialization
            to create copies when the Instance is built.
            </summary>
            <param name="template"></param>
            <returns></returns>
        </member>
        <member name="T:StructureMap.Configuration.DSL.SetterConvention">
            <summary>
            Used as an expression builder to specify setter injection policies
            </summary>
        </member>
        <member name="M:StructureMap.Configuration.DSL.SetterConvention.OfType``1">
            <summary>
            Directs StructureMap to treat all public setters of type T as
            mandatory properties
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:StructureMap.Configuration.DSL.SetterConvention.TypeMatches(System.Predicate{System.Type})">
            <summary>
            Directs StructureMap to tread all public setters with
            a PropertyType that matches the predicate as a
            mandatory setter
            </summary>
            <param name="predicate"></param>
        </member>
        <member name="M:StructureMap.Configuration.DSL.SetterConvention.Matching(System.Func{System.Reflection.PropertyInfo,System.Boolean})">
            <summary>
            Directs StructureMap to treat all public setters that match the 
            rule as mandatory properties
            </summary>
            <param name="rule"></param>
        </member>
        <member name="M:StructureMap.Configuration.DSL.SetterConvention.WithAnyTypeFromNamespace(System.String)">
            <summary>
            Directs StructureMap to treat all public setters with a property
            type in the specified namespace as mandatory properties
            </summary>
            <param name="nameSpace"></param>
        </member>
        <member name="M:StructureMap.Configuration.DSL.SetterConvention.WithAnyTypeFromNamespaceContainingType``1">
            <summary>
            Directs StructureMap to treat all public setters with a property
            type in the specified namespace as mandatory properties
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:StructureMap.Configuration.DSL.SetterConvention.NameMatches(System.Predicate{System.String})">
            <summary>
            Directs StructureMap to treat all public setters where to property name
            matches the specified rule as a mandatory property
            </summary>
            <param name="rule"></param>
        </member>
        <member name="T:StructureMap.Construction.InstanceBuilder">
            <summary>
            Base class for creating an object instance from an InstanceMemento.  SubClasses are
            emitted for each concrete Plugin with constructor parameters.
            </summary>
        </member>
        <member name="M:StructureMap.Query.EmptyConfiguration.HasImplementations">
            <summary>
            Simply query to see if there are any implementations registered
            </summary>
            <returns></returns>
        </member>
        <member name="P:StructureMap.Query.EmptyConfiguration.Default">
            <summary>
            The "instance" that will be used when Container.GetInstance(PluginType) is called.
            See <see cref="T:StructureMap.Query.InstanceRef">InstanceRef</see> for more information
            </summary>
        </member>
        <member name="P:StructureMap.Query.EmptyConfiguration.Lifecycle">
            <summary>
            The build "policy" for this PluginType.  Used by the WhatDoIHave() diagnostics methods
            </summary>
        </member>
        <member name="P:StructureMap.Query.EmptyConfiguration.Instances">
            <summary>
            All of the <see cref="T:StructureMap.Query.InstanceRef">InstanceRef</see>'s registered
            for this PluginType
            </summary>
        </member>
        <member name="M:StructureMap.Query.GenericFamilyConfiguration.HasImplementations">
            <summary>
            Simply query to see if there are any implementations registered
            </summary>
            <returns></returns>
        </member>
        <member name="P:StructureMap.Query.GenericFamilyConfiguration.Default">
            <summary>
            The "instance" that will be used when Container.GetInstance(PluginType) is called.
            See <see cref="T:StructureMap.Query.InstanceRef">InstanceRef</see> for more information
            </summary>
        </member>
        <member name="P:StructureMap.Query.GenericFamilyConfiguration.Lifecycle">
            <summary>
            The build "policy" for this PluginType.  Used by the WhatDoIHave() diagnostics methods
            </summary>
        </member>
        <member name="P:StructureMap.Query.GenericFamilyConfiguration.Instances">
            <summary>
            All of the <see cref="T:StructureMap.Query.InstanceRef">InstanceRef</see>'s registered
            for this PluginType
            </summary>
        </member>
        <member name="T:StructureMap.Query.IModel">
            <summary>
                Models the state of a Container or ObjectFactory.  Can be used to query for the
                existence of types registered with StructureMap
            </summary>
        </member>
        <member name="M:StructureMap.Query.IModel.HasDefaultImplementationFor(System.Type)">
            <summary>
                Can StructureMap fulfill a request to ObjectFactory.GetInstance(pluginType) from the
                current configuration.  This does not include concrete classes that could be auto-configured
                upon demand
            </summary>
            <param name="pluginType"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Query.IModel.HasDefaultImplementationFor``1">
            <summary>
                Can StructureMap fulfill a request to ObjectFactory.GetInstance&lt;T&gt;() from the
                current configuration.  This does not include concrete classes that could be auto-configured
                upon demand
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Query.IModel.InstancesOf(System.Type)">
            <summary>
                Queryable access to all of the <see cref="T:StructureMap.Query.InstanceRef">InstanceRef</see> for a given PluginType
            </summary>
            <param name="pluginType"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Query.IModel.InstancesOf``1">
            <summary>
                Queryable access to all of the <see cref="T:StructureMap.Query.InstanceRef">InstanceRef</see> for a given PluginType
            </summary>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Query.IModel.HasImplementationsFor(System.Type)">
            <summary>
                Does the current container have existing configuration for the "pluginType"
            </summary>
            <param name="pluginType"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Query.IModel.HasImplementationsFor``1">
            <summary>
                Does the current container have existing configuration for the type T
            </summary>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Query.IModel.DefaultTypeFor``1">
            <summary>
                Find the concrete type for the default Instance of T.
                In other words, when I call Container.GetInstance(Type),
                what do I get?  May be indeterminate
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Query.IModel.DefaultTypeFor(System.Type)">
            <summary>
                Find the concrete type for the default Instance of pluginType.
                In other words, when I call Container.GetInstance(Type),
                what do I get?  May be indeterminate
            </summary>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Query.IModel.For``1">
            <summary>
                Retrieves the configuration for the given type
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Query.IModel.For(System.Type)">
            <summary>
                Retrieves the configuration for the given type
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Query.IModel.EjectAndRemoveTypes(System.Func{System.Type,System.Boolean})">
            <summary>
                Eject all objects, configuration, and Plugin Types matching this filter
            </summary>
            <param name="filter"></param>
        </member>
        <member name="M:StructureMap.Query.IModel.EjectAndRemovePluginTypes(System.Func{System.Type,System.Boolean})">
            <summary>
                Eject all objects and configuration for any Plugin Type that matches this filter
            </summary>
            <param name="filter"></param>
        </member>
        <member name="M:StructureMap.Query.IModel.EjectAndRemove(System.Type)">
            <summary>
                Eject all objects and Instance configuration for this PluginType
            </summary>
            <param name="pluginType"></param>
        </member>
        <member name="M:StructureMap.Query.IModel.GetAllPossible``1">
            <summary>
                Get each and every configured instance that could possibly
                be cast to T
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="P:StructureMap.Query.IModel.PluginTypes">
            <summary>
                Access to all the <seealso cref="T:StructureMap.Query.IPluginTypeConfiguration">Plugin Type</seealso> registrations
            </summary>
        </member>
        <member name="P:StructureMap.Query.IModel.Pipeline">
            <summary>
                Direct access to the configuration model of this container
            </summary>
        </member>
        <member name="P:StructureMap.Query.IModel.AllInstances">
            <summary>
                All explicitly known Instance's in this container.  Other instances can be created during
                the lifetime of the container
            </summary>
        </member>
        <member name="T:StructureMap.Pipeline.UniquePerRequestLifecycle">
            <summary>
            Makes sure that every request for this object returns a unique object
            </summary>
        </member>
        <member name="P:StructureMap.Query.InstanceRef.ConcreteType">
            <summary>
                The actual concrete type of this Instance.  Not every type of IInstance
                can determine the ConcreteType
            </summary>
        </member>
        <member name="M:StructureMap.Query.PluginTypeConfigurationExtensions.EjectAndRemove(StructureMap.Query.IPluginTypeConfiguration,System.String)">
            <summary>
            Ejects and removes all objects and the configuration for the named instance from the 
            container
            </summary>
            <param name="configuration"></param>
            <param name="instanceName"></param>
        </member>
        <member name="M:StructureMap.Query.PluginTypeConfigurationExtensions.EjectAndRemove(StructureMap.Query.IPluginTypeConfiguration,System.Func{StructureMap.Query.InstanceRef,System.Boolean})">
            <summary>
            Ejects and removes all objects and configuration for the instances that match the filter
            </summary>
            <param name="configuration"></param>
            <param name="filter"></param>
        </member>
        <member name="M:StructureMap.TypeRules.TypeExtensions.CanBeCastTo(System.Type,System.Type)">
            <summary>
            Determines if the PluggedType can be upcast to the pluginType
            </summary>
            <param name="pluginType"></param>
            <param name="pluggedType"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.IInitializationExpression.AddRegistry``1">
            <summary>
            Creates and adds a Registry object of type T.  
            </summary>
            <typeparam name="T">The Registry Type</typeparam>
        </member>
        <member name="M:StructureMap.IInitializationExpression.AddRegistry(StructureMap.Configuration.DSL.Registry)">
            <summary>
            Imports all the configuration from a Registry object
            </summary>
            <param name="registry"></param>
        </member>
        <member name="M:StructureMap.Query.Model.For``1">
            <summary>
            Retrieves the configuration for the given type
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Query.Model.For(System.Type)">
            <summary>
            Retrieves the configuration for the given type
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Query.Model.EjectAndRemoveTypes(System.Func{System.Type,System.Boolean})">
            <summary>
            Eject all objects, configuration, and Plugin Types matching this filter
            </summary>
            <param name="filter"></param>
        </member>
        <member name="M:StructureMap.Query.Model.EjectAndRemovePluginTypes(System.Func{System.Type,System.Boolean})">
            <summary>
            Eject all objects and configuration for any Plugin Type that matches this filter
            </summary>
            <param name="filter"></param>
        </member>
        <member name="M:StructureMap.Query.Model.EjectAndRemove(System.Type)">
            <summary>
            Eject all objects and Instance configuration for this PluginType
            </summary>
            <param name="pluginType"></param>
        </member>
        <member name="M:StructureMap.Query.Model.GetAllPossible``1">
            <summary>
            Get each and every configured instance that could possibly
            be cast to T
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="P:StructureMap.Pipeline.IBuildFrame.RequestedType">
            <summary>
            The requested PluginType of the Instance being create
            </summary>
        </member>
        <member name="P:StructureMap.Pipeline.IBuildFrame.Name">
            <summary>
            The Name of the Instance being created
            </summary>
        </member>
        <member name="P:StructureMap.Pipeline.IBuildFrame.ConcreteType">
            <summary>
            The actual ConcreteType being created.  This will not always
            be available
            </summary>
        </member>
        <member name="T:StructureMap.Pipeline.BuildFrame">
            <summary>
            Models the current place in an object graph during the construction of
            an instance.  Provides contextual information that can be used
            to alter the desired construction of child objects
            </summary>
        </member>
        <member name="P:StructureMap.Pipeline.BuildFrame.RequestedType">
            <summary>
            The requested PluginType of the Instance being create
            </summary>
        </member>
        <member name="P:StructureMap.Pipeline.BuildFrame.Name">
            <summary>
            The Name of the Instance being created
            </summary>
        </member>
        <member name="P:StructureMap.Pipeline.BuildFrame.ConcreteType">
            <summary>
            The actual ConcreteType being created.  This will not always
            be available
            </summary>
        </member>
        <member name="T:StructureMap.Pipeline.BuildStack">
            <summary>
            Provides metadata about the object graph being constructed.  More or less a stack trace of the GetInstance() pipeline
            that can be used for "contextual" object construction
            </summary>
        </member>
        <member name="P:StructureMap.Pipeline.BuildStack.Root">
            <summary>
            The top level of the object graph.  Describes the original requested instance
            </summary>
        </member>
        <member name="P:StructureMap.Pipeline.BuildStack.Current">
            <summary>
            The current BuildFrame
            </summary>
        </member>
        <member name="P:StructureMap.Pipeline.BuildStack.Parent">
            <summary>
            The immediate parent BuildFrame
            </summary>
        </member>
        <member name="T:StructureMap.Pipeline.SmartInstance`1">
            <summary>
                Instance that builds objects with by calling constructor functions and using setter properties
            </summary>
            <typeparam name="T">The concrete type constructed by SmartInstance</typeparam>
        </member>
        <member name="M:StructureMap.Pipeline.SmartInstance`1.Named(System.String)">
            <summary>
                Sets the name of this Instance
            </summary>
            <param name="instanceKey"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.SmartInstance`1.OnCreation(System.Action{`0})">
            <summary>
                Register an Action to perform on the object created by this Instance
                before it is returned to the caller
            </summary>
            <param name="handler"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.SmartInstance`1.OnCreation(System.Action{StructureMap.IContext,`0})">
            <summary>
                Register an Action to perform on the object created by this Instance
                before it is returned to the caller
            </summary>
            <param name="handler"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.SmartInstance`1.EnrichWith(StructureMap.Interceptors.EnrichmentHandler{`0})">
            <summary>
                Register a Func to potentially enrich or substitute for the object
                created by this Instance before it is returned to the caller
            </summary>
            <param name="handler"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.SmartInstance`1.EnrichWith``1(StructureMap.Interceptors.EnrichmentHandler{``0})">
            <summary>
                Register a Func to potentially enrich or substitute for the object
                created by this Instance before it is returned to the caller
            </summary>
            <param name="handler"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.SmartInstance`1.EnrichWith(StructureMap.Interceptors.ContextEnrichmentHandler{`0})">
            <summary>
                Register a Func to potentially enrich or substitute for the object
                created by this Instance before it is returned to the caller
            </summary>
            <param name="handler"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.SmartInstance`1.EnrichWith``1(StructureMap.Interceptors.ContextEnrichmentHandler{``0})">
            <summary>
                Register a Func to potentially enrich or substitute for the object
                created by this Instance before it is returned to the caller
            </summary>
            <param name="handler"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.SmartInstance`1.InterceptWith(StructureMap.Interceptors.InstanceInterceptor)">
            <summary>
                Register an <see cref="T:StructureMap.Interceptors.InstanceInterceptor">InstanceInterceptor</see> with this Instance
            </summary>
            <param name="interceptor"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.SmartInstance`1.SetProperty(System.Action{`0})">
            <summary>
                Set simple setter properties
            </summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.SmartInstance`1.Setter``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
            <summary>
                Inline definition of a setter dependency.  The property name is specified with an Expression
            </summary>
            <typeparam name="TSettertype"></typeparam>
            <param name="expression"></param>
            <returns></returns>
        </member>
        <member name="T:StructureMap.ExpressionVisitorBase">
            <summary>
            Provides virtual methods that can be used by subclasses to parse an expression tree.
            </summary>
            <remarks>
            This class actually already exists in the System.Core assembly...as an internal class.
            I can only speculate as to why it is internal, but it is obviously much too dangerous
            for anyone outside of Microsoft to be using...
            </remarks>
        </member>
        <member name="M:StructureMap.Util.Cache`2.FillDefault(`0)">
            <summary>
              Guarantees that the Cache has the default value for a given key.
              If it does not already exist, it's created.
            </summary>
            <param name = "key"></param>
        </member>
    </members>
</doc>
