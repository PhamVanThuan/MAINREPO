'use strict';
angular.module('sahl.js.ui.filters', [])
angular.module('sahl.js.ui.forms',[]);
angular.module('sahl.js.ui.graphing', ['sahl.js.core.arrays']);
angular.module('sahl.js.ui.notifications', [])
angular.module('sahl.js.ui.pages', []);
angular.module('sahl.js.ui.forms.validation',[]);
angular.module('sahl.js.ui.activityManagement', [
    'sahl.js.core.activityManagement'
])
.directive('spinLoader', ['$activityManager', function ($activityManager) {
    return {
        restrict: 'A',
        scope: {},
        link: function (scope, element, attr) {
            var spinner;
            var opts = {
                length: 12,
                radius: 12,
                width: 6,
                color: '#FF6600',
                trail: 40
            };
            var activityName = attr.spinLoader;
            var target = element;
            var timer;

            function onActivityStart() {
                timer = setTimeout(function () {
                    if (!spinner) {
                        spinner = new Spinner(opts);
                    }
                    spinner.spin(target[0]);
                    target.addClass('spinLoad');
                    target.find('*').attr('disabled', true);
                }, 200);
            }

            function onActivityStop() {
                if (timer) {
                    clearTimeout(timer);
                }
                if (spinner) {
                    spinner.stop();
                    target.removeClass('spinLoad');
                    target.find('*').attr('disabled', false);
                }
            }

            $activityManager.registerSpinListenerForKey(onActivityStart, onActivityStop, activityName, element[0].id);

            scope.$on('$destroy', function () {
                $activityManager.removeListenerForKey(element[0].id, activityName);
            });
        }
    };
}]);
angular.module('sahl.js.ui.filters')
    
.filter('currencyFilter', ['$filter', function($filter) {
        return function(amount, fractionSize) {
            var currencyFilter = $filter('currency');
            var currencySymbol = 'R';
            var currencyAmount = currencyFilter(amount, currencySymbol,fractionSize);

            if (amount < 0) {
                return currencyAmount.replace('(', '-').replace(')', '');
            }
            return currencyAmount;
        };
    }]);
angular.module('sahl.js.ui.filters')
.filter('dateViewFilter', function () {
    return function (input) {
        if (_.isEmpty(input)) {
            return "-";
        }
        if (input === "0001-01-01T00:00:00") {
            return "-";
        }
        return moment(input).format("DD/MM/YYYY");
    };
});
angular.module('sahl.js.ui.filters')
.filter('emptyStringDecorator', function () {
    return function (input) {
        if (_.isEmpty(input)) {
            return "-";
        }
        return input;
    };
});
angular.module('sahl.js.ui.filters')
.filter('moneyFilter', ['$locale', function ($locale) {
    return function (amount, currencySymbol) {
        
    };
}]);
// This filter makes the assumption that the input will be in decimal form (i.e. 17% is 0.17).
angular.module('sahl.js.ui.filters')
    .filter('percentage', ['$filter', function($filter) {
        return function(input, decimals) {
            return $filter('number')(input * 100, decimals) + '%';
        };
    }]);

angular.module('sahl.js.ui.filters')
  .filter('visibleColumns', ['$filter', function($filter) {
    return function(data, grid, query) {
      var matches = [];

      if (query === undefined|| query==='') {
        return data;
      }    
      query = query.toLowerCase();
        for (var i = 0; i < data.length; i++) {
          for (var j = 0; j < grid.columnDefs.length; j++) {
          
            var dataItem = data[i];
            var fieldName = grid.columnDefs[j]['field'];
            
            //as soon as search term is found, add to match and move to next dataItem
            if (dataItem[fieldName].toString().toLowerCase().indexOf(query)>-1) {
              matches.push(dataItem);
              break;
            }
          }
        }
      return matches;
    };
}]);
angular.module('sahl.js.ui.forms')
.service('$viewManagerService', ['$rootScope', function ($rootScope) {
    var internal = {
        viewlocation: '.views/lib/views/',
        editViewPostfix : '.edit.tpl.html',
        viewPostfix: '.tpl.html',
        base: function (modelType,splitChar,section) {
            var split = (modelType.indexOf(',') > -1 ? modelType.substr(0, modelType.indexOf(',')) : modelType).split(splitChar);
            split[1] = _.map(split[1].split('.'), function (key) {
                return key.charAt(0).toLowerCase() + key.slice(1);
            }).join('/');
            split[0] = split[0].toLowerCase();
            return split.join(internal.viewlocation+section);
        },
        getView: function (modelType) {
            return internal.base(modelType,'.Models.','tiles/') + internal.viewPostfix;
        },
        getEditView: function (modelType) {
            return internal.base(modelType,'.Models.','tiles/') + internal.editViewPostfix;
        },
        getPageView: function (modelType) {
            return internal.base(modelType,'.Pages.','pages/') + internal.viewPostfix;
        },
        getWizardPage: function (modelType) {
            return internal.base(modelType, '.Configuration.', 'wizardPages/') + internal.viewPostfix;
        },
        getDashboardView: function (modelType) {
            return internal.base(modelType, '.Configuration.', '') + internal.viewPostfix;
        }
    };
    return {
        getView: internal.getView,
        getEditView: internal.getEditView,
        getPageView: internal.getPageView,
        getWizardPage: internal.getWizardPage,
        getDashboardView : internal.getDashboardView
    };
}]);


angular.module('sahl.js.ui.helper', [])
    .service('$uiHelperService', ['$rootScope', function ($rootScope) {

            var operations = {
                getIconForProduct: function (type, productKey) {
                    if (type === "Account") {
                        return processProductKey(productKey, "acc");
                    }

                    if (type === "Application") {
                        return processProductKey(productKey, "app");
                    }

                    return "";
                }
            };

            function processProductKey(productKey, productKeyType) {
                if (productKey === 1 || productKey === 2 || productKey === 5 || productKey === 6 || productKey === 9 || productKey === 11) {
                    return productKeyType + "-mortgage-open";
                }

                if (productKey === 3) {
                    return productKeyType + "-hoc-open";
                }

                if (productKey === 4) {
                    return productKeyType + "-life-open";
                }

                return "";
            }

            return {
                getIconForProduct: operations.getIconForProduct,
                start: function () {
                    $rootScope.getIconForProduct = operations.getIconForProduct;
                }
            };
        }
    ]);


angular.module('sahl.js.ui.graphing')
    .service('$graphMathService', ['$rootScope', function ($rootScope) {
            var constants = {
                rad: (Math.PI / 180)
            };

            var points = {
                getCurvePoints: function (previous, current, next) {
                    var partialDiffX1 = (current.x - previous.x) / 2,
                        partialDiffX2 = (next.x - current.x) / 2,
                        a = Math.atan((current.x - previous.x) / Math.abs(current.y - previous.y)),
                        b = Math.atan((next.x - current.x) / Math.abs(current.y - next.y));
                    a = previous.y < current.y ? Math.PI - a : a;
                    b = next.y < current.y ? Math.PI - b : b;
                    var alpha = Math.PI / 2 - ((a + b) % (Math.PI * 2)) / 2;
                    return {
                        previous: { 'x': (current.x - (partialDiffX1 * Math.sin(alpha + a))), 'y': (current.y + (partialDiffX1 * Math.cos(alpha + a))) },
                        next: { 'x': (current.x + (partialDiffX2 * Math.sin(alpha + b))), 'y': (current.y + (partialDiffX2 * Math.cos(alpha + b))) }
                    };
                }
            };

            var lines = {
                getPoint: function (ratioX, ratioY, valueX, valueY, zeroX, zeroY, gutter) {
                    var x = (valueX - zeroX) * ratioX;
                    var y = (zeroY - valueY) * ratioY;
                    return { 'x': x + gutter, 'y': y + gutter };
                },
                getStartingPoint: function (point, isCurvy) {
                    if (isCurvy) {
                        return ['M', point.x, point.y, 'C', point.x, point.y];
                    }
                    return ['M', point.x, point.y, 'L'];
                },
                lineTo: function (previous, current, next, isCurvy) {
                    if (isCurvy) {
                        var tempPoints = points.getCurvePoints(previous, current, next);
                        return [tempPoints.previous.x, tempPoints.previous.y, current.x, current.y, tempPoints.next.x, tempPoints.next.y];
                    }
                    return [current.x, current.y];
                },
                getEndPoint: function (current) {
                    return [current.x, current.y, current.x, current.y];
                },
                horizontalLine: function (positionY, width, gutter) {
                    return ['M', 0 + gutter, positionY, 'L', width-gutter, positionY, 'z'];
                },
                verticalLine: function (positionX, height, gutter) {
                    return ['M', positionX, 0 + gutter, 'L', positionX, height - gutter, 'z'];
                }
            };

            var pathing = {
                getDoughnutSectionPath: function (positionX, positionY, radius, innerRadius, startAngle, endAngle) {
                    var x1 = positionX + radius * Math.cos(-startAngle * constants.rad),
                        x2 = positionX + radius * Math.cos(-endAngle * constants.rad),
                        y1 = positionY + radius * Math.sin(-startAngle * constants.rad),
                        y2 = positionY + radius * Math.sin(-endAngle * constants.rad),
                        xx1 = positionX + innerRadius * Math.cos(-startAngle * constants.rad),
                        xx2 = positionX + innerRadius * Math.cos(-endAngle * constants.rad),
                        yy1 = positionY + innerRadius * Math.sin(-startAngle * constants.rad),
                        yy2 = positionY + innerRadius * Math.sin(-endAngle * constants.rad);
                    return ['M', xx1, yy1, 'L', x1, y1, 'A', radius, radius, 0, +(endAngle - startAngle > 180), 0, x2, y2, 'L', xx2, yy2, 'A',
                            innerRadius, innerRadius, 0, +(endAngle - startAngle > 180), 1, xx1, yy1, 'z'];
                },

                getPieSectionPath: function (positionX, positionY, radius, startAngle, endAngle) {
                    var x1 = positionX + radius * Math.cos(-startAngle * constants.rad),
                        x2 = positionX + radius * Math.cos(-endAngle * constants.rad),
                        y1 = positionY + radius * Math.sin(-startAngle * constants.rad),
                        y2 = positionY + radius * Math.sin(-endAngle * constants.rad);
                    return ['M', positionX, positionY, 'L', x1, y1, 'A', radius, radius, 0, +(endAngle - startAngle > 180), 0, x2, y2, 'L', positionX, positionY, 'z'];
                },
                getBar: function (valuePoint, zeroPoint, width) {
                    return ['M', zeroPoint.x, zeroPoint.y, 'L', valuePoint.x, valuePoint.y, 'L', valuePoint.x + width, valuePoint.y, 'L',
                            valuePoint.x + width, zeroPoint.y, 'L', zeroPoint.x, zeroPoint.y, 'z'];
                },
                getPopupPath: function (positionX, positionY, width, height, padding, space, isLeft, isTop) {
                    var x1 = positionX - padding;
                    var y1 = positionY - padding;
                    var x2 = positionX + width + padding;
                    var y2 = positionY + height + padding;

                    var pointerPointX = isLeft ? x1 - space : x2 + space;
                    var pointerPointY = isTop ? positionY + space + 1 : positionY + height - (1 + space);
                    var pointPointY1 = pointerPointY + space;
                    var pointPointY2 = pointerPointY - space;
                    var retVal = ['M', x1, y1, 'L', x2, y1];
                    if (!isLeft) {
                        retVal = retVal.concat(['L', x2, pointPointY2, 'L', pointerPointX, pointerPointY, 'L', x2, pointPointY1 ]);
                    }
                    retVal = retVal.concat(['L', x2, y2, 'L', x1, y2]);
                    if (isLeft) {
                        retVal = retVal.concat(['L', x1, pointPointY1, 'L', pointerPointX, pointerPointY, 'L', x1, pointPointY2 ]);
                    }
                    return retVal.concat(['z']);
                }
            };

            return {
                getDoughnutSectionPath: pathing.getDoughnutSectionPath,
                getPieSectionPath: pathing.getPieSectionPath,
                getCurvePoints: points.getCurvePoints,
                getPoint: lines.getPoint,
                getStartingPoint: lines.getStartingPoint,
                getEndPoint: lines.getEndPoint,
                lineTo: lines.lineTo,
                horizontalLine: lines.horizontalLine,
                verticalLine: lines.verticalLine,
                getBar: pathing.getBar,
                getPopupPath: pathing.getPopupPath
            };
        }]);


angular.module('sahl.js.ui.graphing')
    .service('$popupHelperService', ['$graphMathService', function ($graphMathService) {
            var fixedGap = 10;
            var textHelper = {
                getDefaultedText: function (paper, raphaelTextObject, textArray) {
                    for (var i = 0, c = textArray.length; i < c; i++) {
                        raphaelTextObject.push(paper.text(0, 0, textArray[i].text).attr(textArray[i].attr).attr({ 'text-anchor': 'start' }));
                    }
                    var totalHeight = 0;
                    for (var ii = 0, cc = raphaelTextObject.length; ii < cc; ii++) {
                        var bbx = raphaelTextObject[ii].getBBox();
                        raphaelTextObject[ii].attr({ y: (bbx.height / 2) + totalHeight });
                        totalHeight = totalHeight + bbx.height;
                    }
                    return raphaelTextObject.getBBox();
                },
                moveText: function (x, y, space, text, textBoxBoundry, isLeft, isTop) {
                    var diff = space + fixedGap;
                    var newX = isLeft ? x + diff : x - diff - textBoxBoundry.width;
                    var newY = isTop ? y - space : y - textBoxBoundry.height + space;
                    text.translate(newX, newY);
                }
            };

            var backgroundHelper = {
                isLeft: function (x, space, textWidth, canvasWidth) {
                    var total = x + fixedGap + space + textWidth;
                    if (total > canvasWidth) {
                        return false;
                    }
                    return true;
                },
                isTop: function (y, space, textHeight, canvasHeight) {
                    var total = y + fixedGap + space + textHeight;
                    if (total > canvasHeight) {
                        return false;
                    }
                    return true;
                },
                setBackground: function (bBox, x, y, space, isLeft, isTop) {
                    return $graphMathService.getPopupPath(bBox.x, bBox.y, bBox.width, bBox.height, 5, space, isLeft, isTop);
                }
            };

            var popup = function (paper) {
                var _self = this;

                var popupSet = paper.set();
                var text = paper.set();
                var background = paper.path().attr({ fill: '#000', stroke: '#666', 'stroke-width': 2, 'fill-opacity': 0.8 });
                popupSet.push(background);

                _self.hide = function () {
                    popupSet.hide();
                };

                _self.update = function (textArray, x, y, space, width, height) {
                    text.remove();
                    text.clear();
                    var textBoxBoundry = textHelper.getDefaultedText(paper, text, textArray);
                    var isLeft = backgroundHelper.isLeft(x, space, textBoxBoundry.width, width);
                    var isTop = backgroundHelper.isTop(y, space, textBoxBoundry.height, height);

                    textHelper.moveText(x, y, space, text, textBoxBoundry, isLeft, isTop);

                    var backgroundPath = backgroundHelper.setBackground(text.getBBox(), x, y, space, isLeft, isTop);

                    background.attr({ path: backgroundPath, fill: '#000' });
                    popupSet.push(text);

                    background.toFront();
                    text.toFront();
                    popupSet.show();
                };

                _self.hide();

                return _self;
            };

            var external = {
                createPopup: function (paper) {
                    return new popup(paper);
                }
            };
            return {
                createPopup: external.createPopup
            };
        }]);


angular.module('sahl.js.ui.graphing')
    .directive('sahlBar', ['$arrayHelperService', '$graphMathService', '$popupHelperService', function ($arrayHelperService, $graphMathService, $popupHelperService) {
        return {
            restrict: 'A',
            require: ['^sahlCanvas', '?^sahlGrid'],
            scope: {
                data: '=',
                mouseover: '=',
                mouseout: '=',
                format: '='
            },
            link: function (scope, element, attrs, controllers) {
                var canvasController = controllers[0];
                var gridController = controllers[1];
                if (!attrs.width || !attrs.height) {
                    //don't register a thing as there a missing attributes.
                    return;
                }

                var internal = {
                    init: function () {
                        scope.fullWidth = attrs.width ? Number(attrs.width) : 0;
                        scope.fullHeight = attrs.height ? Number(attrs.height) : 0;
                        //where most of our minds go, this is actually like a padding, but for the dots
                        scope.gutter = attrs.gutter ? Number(attrs.gutter) : 0;
                        scope.width = attrs.width ? Number(attrs.width) - (scope.gutter * 2) : 0;
                        scope.height = attrs.height ? Number(attrs.height) - (scope.gutter * 2) : 0;
                        scope.gap = attrs.gap ? Number(attrs.gap) : 4;
                    },
                    events: function (barPiece, popup, x, y, data) {
                        (function (barPiece, popup, x, y, data) {
                            var text = internal.popupText(data);
                            barPiece.hover(function (element) {
                                popup.update(text, x - 5, y, 6, scope.width, scope.height);
                                scope.mouseover && scope.mouseover(data);
                            }, function (element) {
                                popup.hide();
                                scope.mouseout && scope.mouseout(data);
                            });
                        })(barPiece, popup, x, y, data);
                    },
                    popupText: function (dataValue, color) {
                        if (scope.format) {
                            return scope.format(dataValue, color);
                        }
                        return [
                            {
                                text: dataValue.value,
                                attr: {
                                    font: '12px Helvetica, Arial',
                                    fill: '#fff'
                                }
                            }
                        ];
                    }
                };

                internal.init();

                if (!scope.data) {
                    return;
                }

                scope.id = canvasController.addInstruction(function (paper) {
                    var maxy = $arrayHelperService.max(scope.data, function (item) {
                        return item.value;
                    });
                    var miny = $arrayHelperService.min(scope.data, function (item) {
                        return item.value;
                    });
                    miny = (miny > 0) ? 0 : miny;
                    var rangeY = maxy - miny;
                    var zeroPointY = maxy;
                    var ratioY = scope.height / rangeY;
                    var barWidth = (scope.width - (scope.gap * (scope.data.length + 1))) / scope.data.length;
                    if (gridController) {
                        gridController.render(paper, scope.fullWidth, scope.fullHeight, scope.gutter, 0, rangeY, 0, zeroPointY, 1, ratioY);
                    }
                    var popup = $popupHelperService.createPopup(paper);
                    for (var i = 0, c = scope.data.length; i < c; i++) {
                        var pointValue = $graphMathService.getPoint(1, ratioY, ((i + 1) * scope.gap) + (i * barWidth), scope.data[i].value, 0, zeroPointY, scope.gutter);
                        var pointZero = $graphMathService.getPoint(1, ratioY, ((i + 1) * scope.gap) + (i * barWidth), 0, 0, zeroPointY, scope.gutter);
                        var path = $graphMathService.getBar(pointValue, pointZero, barWidth);
                        var barPiece = paper.path(path).attr({fill: scope.data[i].color, 'stroke-width': 0});
                        internal.events(barPiece, popup, pointValue.x + barWidth, pointValue.y, scope.data[i]);
                    }
                });

                scope.$watch('data', function (newValue, oldValue) {
                    if (oldValue !== newValue) {
                        canvasController.redraw(scope.id);
                    }
                });
            }
        };
    }]);


angular.module('sahl.js.ui.graphing')
    .directive('sahlCanvas', ['$window', function ($window) {
        return {
            restrict: 'A',
            scope: {
            },
            controller: ['$scope', function ($scope) {
                $scope.canvasElement = undefined;
                $scope.canvasElements = [];
                var internal = {
                    addInstruction: function (fn) {
                        return $scope.canvasElements.push({ 'fn': fn, 'set': undefined }) - 1;
                    },

                    draw: function () {
                        var length = $scope.canvasElements.length - 1;
                        for (var i = length; i >= 0; i--) {
                            $scope.canvasElement.setStart();
                            $scope.canvasElements[i].fn($scope.canvasElement);
                            $scope.canvasElements[i].set = $scope.canvasElement.setFinish();
                        }
                    },
                    redraw: function (instructionId) {
                        $scope.canvasElements[instructionId].set.remove();
                        $scope.canvasElement.setStart();
                        $scope.canvasElements[instructionId].fn($scope.canvasElement);
                        $scope.canvasElements[instructionId].set = $scope.canvasElement.setFinish();
                        for (var i = instructionId - 1; i >= 0; i--) {
                            $scope.canvasElements[i].set.toFront();
                        }
                    },
                    getWidth : function(){
                      return $scope.width;
                    },
                    getHeight : function(){
                      return $scope.height;
                    }
                };

                $scope.draw = internal.draw;
                $scope.setCanvas = function (canvas,width,height) {
                    $scope.canvasElement = canvas;
                    $scope.canvasElement.setViewBox(0,0,width,height,true);
                    var element = $($scope.canvasElement.canvas);
                    element.removeAttr('width');
                    element.removeAttr('height');
                    element.attr('preserveAspectRatio','none');
                    element.addClass('full-height');
                    element.addClass('full-width');

                };

                this.addInstruction = internal.addInstruction;
                this.redraw = internal.redraw;
                this.getWidth = internal.getWidth;
                this.getHeight = internal.getHeight;
            }],
            link: function ($scope, element, attrs, controller) {
              if(attrs.width){
                $scope.width = Number(attrs.width);
              }else{
                var width = 0;
                if(element && element['width']){
                   width = element.width();
                }
                attrs.width = $scope.width = width;
              }
              if(attrs.height){
                $scope.height = Number(attrs.height);
              }else{
                var height = 0;
                if(element && element['parent'] && element.parent()['height']){
                   height = element.parent().height();
                }
                attrs.height = $scope.height = height;
              }

              element.ready(function () {
                  $scope.setCanvas(Raphael($(element)[0]),$scope.width, $scope.height);
                  $scope.draw();
              });
            }
        };
    }]);

angular.module('sahl.js.ui.graphing')
.directive('sahlDoughnut', ['$graphMathService', '$popupHelperService', function ($graphMathService, $popupHelperService) {
    return {
        restrict: 'A',
        require: '^sahlCanvas',
        scope: {
            data: '=',
            mouseover: '=',
            mouseout: '=',
            format: '='
        },
        link: function (scope, element, attrs, canvasController) {
            scope.x = attrs.x ? Number(attrs.x) : 0.5;
            scope.y = attrs.y ? Number(attrs.y) : 0.5;
            if (!attrs.radius) {
                throw 'radius is a required field';
            }
            scope.radius = Number(attrs.radius);
            scope.innerRadius = attrs.innerradius ? Number(attrs.innerradius) : 0.4 * scope.radius;

            var internal = {
                events: function (doughPiece, popup, data) {
                    (function (doughPiece, popup, data) {
                        var text = internal.popupText(data);
                        doughPiece.hover(function (element) {
                            popup.update(text, element.offsetX, element.offsetY, 6, scope.width, scope.height);
                            doughPiece.g = doughPiece.glow();
                            scope.mouseover && scope.mouseover(data);
                        }, function (element) {
                            popup.hide();
                            doughPiece.g && doughPiece.g.remove();
                            scope.mouseout && scope.mouseout(data);
                        });
                    })(doughPiece, popup, data);
                },
                popupText: function (dataValue, color) {
                    if (scope.format) {
                        return scope.format(dataValue, color);
                    }
                    return [{ text: dataValue.value, attr: { font: '12px Helvetica, Arial', fill: '#fff' } }];
                }
            };

            scope.id = canvasController.addInstruction(function (paper) {
                var total = 0,
                startAngle = 0;
                for (var index in scope.data) {
                    if (scope.data.hasOwnProperty(index)) {
                        total += scope.data[index].value;
                    }
                }
                var popup = $popupHelperService.createPopup(paper);
                for (var key in scope.data) {
                    if (scope.data.hasOwnProperty(key)) {
                        var endAngle = startAngle + (360 / total * scope.data[key].value);
                        var path = $graphMathService.getDoughnutSectionPath(scope.radius + scope.x, scope.radius + scope.y, scope.radius, scope.innerRadius, startAngle, endAngle);
                        var doughPiece = paper.path(path).attr({ fill: scope.data[key].color, 'stroke-width': 0.5 });
                        internal.events(doughPiece, popup, scope.data[key]);
                        startAngle = endAngle;
                    }
                }
            });

            scope.$watch('data', function (newValue, oldValue) {
                if (newValue !== oldValue) {
                    canvasController.redraw(scope.id);
                }
            });
        }
    };
}]);
angular.module('sahl.js.ui.graphing')
.directive('sahlGrid', ['$graphMathService', function ($graphMathService) {
    return {
        restrict: 'A',
        require: '^sahlCanvas',
        scope:{},
        controller: ['$scope', function ($scope) {
            var internal = {
              calculateStep :function(range){
                var exp = Math.round(Math.log10(range));
                var power = Math.pow(10,exp);
                var step = (range/(power/5)) > 1 ? (power/5) : (power/10);
                return step;
              },
              render: function (paper, width, height, gutter, rangeX, rangeY, zeroPointX, zeroPointY, ratioX, ratioY,maxx,maxy) {
                  var zeroPoint = $graphMathService.getPoint(ratioX, ratioY, 0, 0, zeroPointX, zeroPointY, gutter);

                  if ($scope.showxaxis) {
                    paper.path($graphMathService.horizontalLine(zeroPoint.y, width, gutter)).attr({ 'stroke': '#555555', 'stroke-width': 0.1 });
                  }

                  if ($scope.showyaxis) {
                    paper.path($graphMathService.verticalLine(zeroPoint.x, height, gutter)).attr({ 'stroke': '#555555', 'stroke-width': 0.1 });
                  }

                  if($scope.ylines){
                    var step = internal.calculateStep(rangeY);
                    var count = 0;
                    var xLocation =  zeroPoint.x-5;
                    while((count+step) < maxy){
                      count = count + step;
                      var yLocation = zeroPoint.y - (count*ratioY);
                      paper.path($graphMathService.horizontalLine(yLocation,width, gutter)).attr({ 'stroke': '#555555', 'stroke-width': 0.1 });
                      paper.text(xLocation, yLocation, count).attr({'text-anchor': 'end','font-size':'14px','font-weight':'bold'});
                    }
                  }

                  if($scope.xlines){

                  }
              }
            };
            this.render = internal.render;
        }],
        link: function (scope, element, attrs, ngModel) {
            scope.showxaxis = attrs.showxaxis ? (attrs.showxaxis === 'true' ? true : false) : false;
            scope.showyaxis = attrs.showyaxis ? (attrs.showyaxis === 'true' ? true : false) : false;
            scope.ylines = attrs.ylines ? (attrs.ylines === 'true' ? true : false) : false;
        }
    };
}]);


angular.module('sahl.js.ui.graphing')
//this one is a little more hairy than the others, but it's totally worth it.
.directive('sahlLines', ['$arrayHelperService', '$graphMathService', '$popupHelperService', function ($arrayHelperService, $graphMathService, $popupHelperService) {
    return {
        restrict: 'A',
        require: ['^sahlCanvas', '?^sahlGrid'],
        scope: {
            data: '=',
            mouseover: '=',
            mouseout: '=',
            format: '='
        },
        link: function (scope, element, attrs, controllers) {
            var canvasController = controllers[0];
            var gridController = controllers[1];


            var internal = {
                init: function (width,height) {
                    scope.curved = attrs.curved ? true : false;
                    //where most of our minds go, this is actually like a padding, but for the dots
                    scope.gutter = attrs.gutter ? Number(attrs.gutter) : 0;
                    scope.width = width - (scope.gutter * 2);
                    scope.height = height - (scope.gutter * 2);
                    scope.strokeWidth = attrs.strokewidth ? Number(attrs.strokewidth) : 2;
                    scope.hidepoints = attrs.hidepoints ? (attrs.hidepoints === 'true' ? true : false) : false;
                    scope.pointradius = attrs.pointradius ? Number(attrs.pointradius) : 4;
                },
                events: function (dot, dotX, dotY, dataValue, popup, color,dataIndex) {
                    var text = internal.popupText(dataIndex,color, dataValue);
                    (function (dot, dotX, dotY, text, popup, color) {
                        dot.hover(function (element, mouseX, mouseY) {
                            var space = scope.pointradius * 1.4;
                            popup.update(text, dotX, dotY, space, scope.width, scope.height);
                            dot.attr('r', space);
                            scope.mouseover && scope.mouseover(data);
                        }, function (element) {
                            popup.hide();
                            dot.attr('r', scope.pointradius);
                            scope.mouseout && scope.mouseout(data);
                        });
                    })(dot, dotX, dotY, text, popup, color);
                },
                popupText: function (dataIndex,color, dataValue) {
                    var c = Raphael.color(color);
                    if (scope.format) {
                        return scope.format(dataIndex,dataValue, color);
                    }
                    return [{ text: dataValue.x, attr: { font: '12px Helvetica, Arial', fill: '#fff' } },
                            { text: dataValue.y, attr: { font: '10px Helvetica, Arial', fill: Raphael.hsl(c.h, c.s, c.l * 1.4) } }];
                }
            };

            if (!scope.data) {
                return;
            }



            scope.id = canvasController.addInstruction(function (paper) {
                scope.fullWidth = attrs.width ? Number(attrs.width) : (canvasController.getWidth());
                scope.fullHeight = attrs.height ? Number(attrs.height) :(canvasController.getHeight());
                internal.init(scope.fullWidth,scope.fullHeight);

                var maxy = $arrayHelperService.max(scope.data, function (itemArray) {
                    return $arrayHelperService.max(itemArray.values, function (value) {
                        return value.y;
                    });
                });
                var miny = $arrayHelperService.min(scope.data, function (itemArray) {
                    return $arrayHelperService.min(itemArray.values, function (value) {
                        return value.y;
                    });
                });

                var maxx = $arrayHelperService.max(scope.data, function (itemArray) {
                    return $arrayHelperService.max(itemArray.values, function (value) {
                        return value.x;
                    });
                });
                var minx = $arrayHelperService.min(scope.data, function (itemArray) {
                    return $arrayHelperService.min(itemArray.values, function (value) {
                        return value.x;
                    });
                });

                var endSpace = 0;
                if(minx > 0){
                  endSpace = minx;
                }

                miny = miny > 0 ? 0 : miny;
                minx = minx > 0 ? 0 : minx;

                var rangeY = maxy - miny;
                var rangeX = maxx - minx;
                var zeroPointY = maxy;
                var zeroPointX = minx;
                var ratioY = scope.height / rangeY;
                var ratioX = scope.width / (rangeX+endSpace);
                var points = paper.set();
                var popup;
                if (gridController) {
                    gridController.render(paper, scope.fullWidth, scope.fullHeight, scope.gutter, rangeX, rangeY, zeroPointX, zeroPointY, ratioX, ratioY,maxx,maxy);
                }
                if (!scope.hidepoints) {
                    popup = $popupHelperService.createPopup(paper);
                }

                for (var i = 0, c = scope.data.length; i < c; i++) {
                    var data = scope.data[i].values;
                    var path = paper.path().attr({ 'stroke': scope.data[i].color, 'stroke-width': scope.strokeWidth });
                    var dotStyle = { 'fill': '#FFF', 'stroke': scope.data[i].color, 'stroke-width': (scope.pointradius / 2) };
                    var pathPoints;
                    for (var ii = 0, cc = data.length; ii < cc; ii++) {
                        var point = $graphMathService.getPoint(ratioX, ratioY, data[ii].x, data[ii].y, zeroPointX, zeroPointY, scope.gutter);
                        if (!scope.hidepoints) {
                            var dot = paper.circle(point.x, point.y, scope.pointradius).attr(dotStyle);
                            internal.events(dot, point.x, point.y, data[ii], popup, scope.data[i].color,i);
                            points.push(dot, popup);
                        }

                        if (ii === 0) {
                            pathPoints = $graphMathService.getStartingPoint(point, scope.curved);
                        } else if (ii === (cc - 1)) {
                            pathPoints = pathPoints.concat($graphMathService.getEndPoint(point));
                        } else {
                            var previous = $graphMathService.getPoint(ratioX, ratioY, data[ii - 1].x, data[ii - 1].y, zeroPointX, zeroPointY, scope.gutter);
                            var next = $graphMathService.getPoint(ratioX, ratioY, data[ii + 1].x, data[ii + 1].y, zeroPointX, zeroPointY, scope.gutter);
                            pathPoints = pathPoints.concat($graphMathService.lineTo(previous, point, next, scope.curved));
                        }
                    }
                    path.attr({ path: pathPoints });
                }
                points.toFront();
            });

            scope.$watch('data', function (newValue, oldValue) {
                if (oldValue !== newValue) {
                    canvasController.redraw(scope.id);
                }
            });
        }
    };
}]);


angular.module('sahl.js.ui.graphing')
    .directive('sahlMultibar', ['$arrayHelperService', '$graphMathService', '$popupHelperService', function ($arrayHelperService, $graphMathService, $popupHelperService) {
        return {
            restrict: 'A',
            require: ['^sahlCanvas', '?^sahlGrid'],
            scope: {
                data: '=',
                mouseover: '=',
                mouseout: '=',
                format: '='
            },
            link: function (scope, element, attrs, controllers) {
                var canvasController = controllers[0];
                var gridController = controllers[1];

                var internal = {
                    init: function (width,height) {
                        scope.gutter = attrs.gutter ? Number(attrs.gutter) : 0;
                        scope.width = width ? width - (scope.gutter * 2) : 0;
                        scope.height = height ? height - (scope.gutter * 2) : 0;
                        scope.gap = attrs.gap ? Number(attrs.gap) : 4;
                    },
                    events: function (barPiece, popup, x, y, data,color,dataIndex) {
                        (function (barPiece, popup, x, y, data) {
                            var text = internal.popupText(dataIndex,color, data);
                            barPiece.hover(function (element) {
                                popup.update(text, x - 5, y, 6, scope.width, scope.height);
                                scope.mouseover && scope.mouseover(data);
                            }, function (element) {
                                popup.hide();
                                scope.mouseout && scope.mouseout(data);
                            });
                        })(barPiece, popup, x, y, data);
                    },
                    popupText: function (dataIndex,color, dataValue) {
                        var c = Raphael.color(color);
                        if (scope.format) {
                            return scope.format(dataIndex,dataValue, color);
                        }
                        return [{ text: dataValue.x, attr: { font: '12px Helvetica, Arial', fill: '#fff' } },
                                { text: dataValue.y, attr: { font: '10px Helvetica, Arial', fill: Raphael.hsl(c.h, c.s, c.l * 1.4) } }];
                    },
                    getAxisInformation : function(data){
                      var maxy = $arrayHelperService.max(data, function (itemArray) {
                          return $arrayHelperService.max(itemArray.values, function (value) {
                              return value.y;
                          });
                      });
                      var miny = $arrayHelperService.min(data, function (itemArray) {
                          return $arrayHelperService.min(itemArray.values, function (value) {
                              return value.y;
                          });
                      });
                      var xAxis = _.union.apply(_,_.map(scope.data,function(item){
                        return _.map(item.values,function(dataitem){
                          return dataitem.x;
                        });
                      }));

                      miny = miny < 0 ? miny : 0;

                      var rangeY = (maxy-miny);
                      return {
                        xAxis : xAxis,
                        maxy : maxy,
                        miny : miny,
                        rangeY : rangeY
                      };
                    }
                };

                if (!scope.data) {
                    return;
                }

                scope.id = canvasController.addInstruction(function (paper) {
                    scope.fullWidth = attrs.width ? Number(attrs.width) : (canvasController.getWidth());
                    scope.fullHeight = attrs.height ? Number(attrs.height) :(canvasController.getHeight());
                    internal.init(scope.fullWidth,scope.fullHeight);

                    var axisInformation = internal.getAxisInformation(scope.data);

                    var ratioY = scope.height / axisInformation.rangeY;

                    var barsPerXValue = scope.data.length;
                    var collectionCount = axisInformation.xAxis.length;

                    var optimalSpacing = scope.width / ((5.0*(barsPerXValue*collectionCount))+(2.0*collectionCount)+3.0);

                    var barWidth = optimalSpacing*4.0;
                    var gapWidth = optimalSpacing*3.0;
                    var spaceWidth = optimalSpacing;

                    if (gridController) {
                        gridController.render(paper, scope.fullWidth, scope.fullHeight, scope.gutter, collectionCount, axisInformation.rangeY, 0, axisInformation.maxy, 1, ratioY,collectionCount,axisInformation.maxy);
                    }

                    var popup = $popupHelperService.createPopup(paper);

                    var xShift = 0;
                    _.each(axisInformation.xAxis,function(axisitem,axisCount){
                      xShift = xShift + gapWidth;
                      _.each(scope.data,function(item,dataCount){
                        var result = _.where(item.values,{x:axisitem});
                        if(dataCount!==0){
                          xShift = xShift + spaceWidth;
                        }
                        if(result.length!==0){
                          var pointValue = $graphMathService.getPoint(1, ratioY, xShift, result[0].y, 0, axisInformation.maxy, scope.gutter);
                          var pointZero = $graphMathService.getPoint(1, ratioY, xShift, 0, 0, axisInformation.maxy, scope.gutter);

                          var path = $graphMathService.getBar(pointValue, pointZero, barWidth);
                          var barPiece = paper.path(path).attr({fill: item.color, 'stroke-width': 0});
                          internal.events(barPiece, popup, pointValue.x + barWidth, pointValue.y, result[0],item.color,dataCount);
                        }
                        xShift = xShift + barWidth;
                      });
                    });
                });

                scope.$watch('data', function (newValue, oldValue) {
                    if (oldValue !== newValue) {
                        canvasController.redraw(scope.id);
                    }
                });
            }
        };
    }]);

angular.module('sahl.js.ui.graphing')
.directive('sahlPie', ['$graphMathService', '$popupHelperService', function ($graphMathService, $popupHelperService) {
    return {
        restrict: 'A',
        require: '^sahlCanvas',
        scope: {
            data: '=',
            mouseover: '=',
            mouseout: '=',
            format: '='
        },
        link: function (scope, element, attrs, canvasController) {
            scope.x = attrs.x ? Number(attrs.x) : 0.5;
            scope.y = attrs.y ? Number(attrs.y) : 0.5;
            if (!attrs.radius) {
                throw new Error('radius is a required field');
            }
            scope.radius = Number(attrs.radius);

            var internal = {
                events: function (piePiece, popup, data) {
                    (function (piePiece, popup, data) {
                        var text = internal.popupText(data);
                        piePiece.hover(function (element) {
                            popup.update(text, element.offsetX, element.offsetY, 6, scope.width, scope.height);
                            piePiece.g = piePiece.glow();
                            scope.mouseover && scope.mouseover(data);
                        }, function (element) {
                            popup.hide();
                            piePiece.g && piePiece.g.remove();
                            scope.mouseout && scope.mouseout(data);
                        });
                    })(piePiece, popup, data);
                },
                popupText: function (dataValue, color) {
                    if (scope.format) {
                        return scope.format(dataValue, color);
                    }
                    return [{ text: dataValue.value, attr: { font: '12px Helvetica, Arial', fill: '#fff' } }];
                }
            };

            scope.id = canvasController.addInstruction(function (paper) {
                var total = 0,
                startAngle = 0;
                var popup = $popupHelperService.createPopup(paper);
                for (var index in scope.data) {
                    if (scope.data.hasOwnProperty(index)) {
                        total += scope.data[index].value;
                    }
                }
                for (var key in scope.data) {
                    if (scope.data.hasOwnProperty(key)) {
                        var endAngle = startAngle + (360 / total * scope.data[key].value);
                        var path = $graphMathService.getPieSectionPath(scope.radius + scope.x, scope.radius + scope.y, scope.radius, startAngle, endAngle);
                        var piePiece = paper.path(path).attr({ fill: scope.data[key].color, 'stroke-width': 0.5 });
                        internal.events(piePiece, popup, scope.data[key]);
                        startAngle = endAngle;
                    }
                }
            });

            scope.$watch('data', function (newValue, oldValue) {
                if (newValue !== oldValue) {
                    canvasController.redraw(scope.id);
                }
            });
        }
    };
}]);
'use strict'

angular.module('sahl.js.ui.modalManager',[])
.service('$modalManagerService', ['$rootScope', '$controller', '$compile', function($rootScope, $controller, $compile){
        var defaultOptions = {
        	overlay : false,
        	width : 500,
        	height : 300,
        	draggable : true,
          	templateUrl : '',
          	controller : '',
          	controllerAs: null,
          	controllerParams: {}
        };

        var internal = {
            loadAngularTemplateData : function(templateUrl){
                  var modalBody = '<div class="modal-body" ng-include="\'' + templateUrl + '\'"></div>';
                  return angular.element(modalBody);
            },
            prepareAngularViewData : function(dialogParams){
                  var modalEl = internal.loadAngularTemplateData(dialogParams.templateUrl);

                  var scope = $rootScope.$new();
                  scope['modalTitle'] = dialogParams.title;
                  scope["closeDialog"] = function(){
                      $.Dialog.close();
                  };

                  var locals = angular.extend({$scope: scope}, dialogParams.controllerParams);
                  var ctrl = $controller(dialogParams.controller, locals);

                  if(typeof(dialogParams.controllerAs) == 'string'){
                    scope[dialogParams.controllerAs] = ctrl;
                  }

                  // Yes, ngControllerController is not a typo
                  modalEl.contents().data('$ngControllerController', ctrl);

                  $compile(modalEl)(scope);
                  return modalEl;
            }
        };

        var operations = {
              loadModalWindow : function(dialogParams){
              		dialogParams = angular.extend(defaultOptions, dialogParams);
                  var modalEl = internal.prepareAngularViewData(dialogParams);
                    $.Dialog({
                        overlay: dialogParams.overlay,
                        shadow: true,
                        flat: true,
                        width: dialogParams.width,
                        height: dialogParams.height,
                        draggable: dialogParams.draggable,
                        title: dialogParams.title,
                        onShow: function(_dialog){
                          $(_dialog.children('.content'))
                          .css("padding","32px 10px 10px 10px")
                          .append(modalEl);
                        }
                    });
            }
        };

        return {
            loadModalWindow : operations.loadModalWindow
        };
}]);
angular.module('sahl.js.ui.notifications')
.provider('$toastManagerService', function () {
    this.configure = function (configuration) {
        for (var key in configuration) {
            if (PNotify.prototype.options && configuration.hasOwnProperty(key) && PNotify.prototype.options.hasOwnProperty(key) && configuration[key]) {
                PNotify.prototype.options[key] = configuration[key];
            }
        }
    };

    this.$get = ['$q', function ($q) {
        var operations = {
            notices: function () {
                return PNotify.notices;
            },
            closeAll: function () {
                PNotify.removeAll();
            },
            notify: function (params) {
                var deferred = $q.defer();
                params.after_close = function (toast, time) {
                    deferred.resolve(toast, time);
                };
                var toast = new PNotify(params);
                return { promise: deferred.promise, toast: toast };
            },
            notice: function (params) {
                return operations.notify(params);
            },
            info: function (params) {
                params.type = 'info';
                return operations.notify(params);
            },
            error: function (params) {
                params.type = 'error';
                params.hide = false;
                return operations.notify(params);
            },
            success: function (params) {
                params.type = 'success';
                return operations.notify(params);
            },
            tooltip: function (text) {
                var params = {
                    text: text,
                    hide: false,
                    buttons: {
                        closer: false,
                        sticker: false
                    },
                    history: { history: false },
                    animate_speed: 100,
                    opacity: .9,
                    icon: false,
                    stack: false,
                    addclass: '',
                    auto_display: false
                };
                return new PNotify(params);
            }

        };
        return {
            notices: operations.notices,
            closeAll: operations.closeAll,
            notify: operations.notify,

            notice: operations.notice,
            info: operations.info,
            error: operations.error,
            success: operations.success,

            tooltip: operations.tooltip
        };
    }];
});

angular.module('sahl.js.ui.notifications')
.directive('toolTip', ['$toastManagerService', '$parse', function ($toastManagerService, $parse) {
  return {
    link: function (scope, element, attrs, ngModel) {
	 var length = attrs.minLength != null ? attrs.minLength : 0;
      var text = $parse(attrs.toolTip)(scope);
	   if(text.length >= length){
	    var toolTip = $toastManagerService.tooltip(text);
		 element.bind("mouseover", function (e) {
		 toolTip.open();
	     toolTip.get().css({ 'top': e.originalEvent.clientY + 12, 'left': e.originalEvent.clientX + 12 });
	     });
	     element.bind("mousemove", function (e) {
		 toolTip.get().css({ 'top': e.originalEvent.clientY + 12, 'left': e.originalEvent.clientX + 12 });
	     });
	     element.bind("mouseout", function (e) {
		 toolTip.remove();
		 });
	     scope.$on('$destroy', function() {
	     toolTip.remove();
	     });
	    }
       }
     };
}]);
angular.module('sahl.js.ui.pages')
    .factory('$pageFactory', ['$rootScope', '$state', function ($rootScope, $state) {
        var pageFactory = function () {
            var internalModel = {
                lastState: null,
                internalReloadFunction: null
            };

            var internal = {
                tileDataFunction: function (fn) {
                    internalModel.internalReloadFunction = fn;
                }
            };

            var operations = {
                setViewData: function (lastState) {
                    internalModel.lastState = lastState;
                },
                back: function (forceReload) {
                    if (internalModel.lastState === null) {
                        throw "no last state found";
                    }

                    $rootScope.entitiesModel.activeEntity.breadcrumbs.pop();
                    $state.go(internalModel.lastState, null);
                    if (forceReload) {
                        internalModel.internalReloadFunction();
                    }
                }
            };


            return {
                internal: internal,
                setViewData: operations.setViewData,
                back: operations.back
            };
        };
        return new pageFactory();
    }]);
angular.module('sahl.js.ui.pages')
    .factory('$wizardFactory', ['$rootScope', '$q', function ($rootScope, $q) {
        var wizardFactory = function () {
            var buttonsVisible = true;
            var changeFn = null;
            var onCompleteFn = null;
			var completed = false;
            var canCancelWorkFlow = true;
            
            var events = {
                YES_WIZARD_CLICKED: 'YES_WIZARD_CLICKED',
                NO_WIZARD_CLICKED: 'NO_WIZARD_CLICKED',
                NEXT_WIZARD_CLICKED: 'NEXT_WIZARD_CLICKED',
                PREVIOUS_WIZARD_CLICKED: 'PREVIOUS_WIZARD_CLICKED',
                CANCEL_WIZARD_CLICKED: 'CANCEL_WIZARD_CLICKED',
                SUBMIT_WIZARD_CLICKED: 'SUBMIT_WIZARD_CLICKED',
                FINISH_WIZARD_CLICKED: 'FINISH_WIZARD_CLICKED'
            };

            var internal = {
                buttonsChanged: function (fnInput) {
                    changeFn = fnInput;
                },
                buttonsVisible: buttonsVisible,
                finished: function () {
                    var awaitables = [];
                    if (onCompleteFn) {
                        var result = onCompleteFn();
                        if (result && result.then) {
                            awaitables.push(result);
                        }
                    }
                    return $q.all(awaitables);
                },
				completed : function(){
					return completed;
				},
                canCancelWorkFlow: function(){
                    return canCancelWorkFlow;
                }
            };

            var operations = {
                hideButtons: function () {
                    buttonsVisible = false;
                    if (changeFn) {
                        changeFn(false);
                    }
                },
                showButtons: function () {
                    buttonsVisible = true;
                    if (changeFn) {
                        changeFn(true);
                    }
                },
                onComplete: function (fn) {
                    onCompleteFn = fn;
                },
				complete : function(){
					completed = true;
				},
                setCanCancelWorkFlowActivity : function(canCancel){
                    canCancelWorkFlow = canCancel;
                }
            };

            return {
                events: events,
                internal: internal,
                hideButtons: operations.hideButtons,
                showButtons: operations.showButtons,
                onComplete: operations.onComplete,
				complete: operations.complete,
                setCanCancelWorkFlowActivity: operations.setCanCancelWorkFlowActivity
            };
        };
        return new wizardFactory();
    }]);
angular.module('sahl.js.ui.forms.decorators', [])
.directive('sahlTag', function () {
    return {
        restrict: 'AC',
        scope: {
            ngModel: '='
        },
        require: 'ngModel',
        link: function (scope, element, attrs, ngModel) {
            angular.element(element).css('background', scope.ngModel.background);
            angular.element(element).css('color', scope.ngModel.forground);
        }
    };
});
angular.module('sahl.js.ui.forms.lookup', ['sahl.js.core.lookup'])
    .directive('lookupDropdown', function() {
        return {
            restrict: 'A',
            scope: {
                lookupId: '=',
                lookupType: '@'
            },
            template: '<div class="input-control select">' +
                '<select ng-model="selectedValue" ng-options="value.description for value in values"></select>' +
                '</div>',
            controller: ['$scope', '$lookupService', function($scope, $lookupService) {
                $scope.getLookupByTypeId = function(lookupId, lookupType) {
                    $lookupService.getByLookupTypeId(lookupType, lookupId).then(function(data) {
                        $scope.selectedValue = data.data.description;
                    });
                };

                $scope.getLookupByType = function(lookupType, selectedId) {
                    $lookupService.getByLookupType(lookupType).then(function(data) {
                        $scope.values = data.data._embedded[lookupType];
                        $scope.selectedValue = _.find($scope.values, function(item) {
                            return item.id === selectedId;
                        });
                    });
                };

            }],
            link: function(scope, element, attrs, ctrls) {
                scope.getLookupByType(scope.lookupType, scope.lookupId);
            }
        };
    });

angular.module('sahl.js.ui.forms.validation')
.directive('errorHint', function () {
    return {
        restrict: 'A',
        require: ['errorHint', '^form'],
        replace: true,
        scope: true,
        controller: ['$scope', function ($scope) {
            $scope.input = null;
            this.setErrors = function (input,form) {
                $scope.input = input;
                $scope.form = form;
            };
        }],
        link: function (scope, element, attrs, ctrls) {
            var control = ctrls[1][attrs.for];
            ctrls[0].setErrors(control, ctrls[1]);
        }
    };
});
angular.module('sahl.js.ui.forms.validation')
.directive('sahlRange', function () {
    var fromFilter = /from\s*:\s*(-?\d+|\*)/gi;
    var toFilter = /to\s*:\s*(-?\d+|\*)/gi;
    var preFromFilter = /from\s*:/gi;
    var preToFilter = /to\s*:\s*/gi;
    return {
        restrict: 'A',
        require: 'ngModel',
        link: function (scope, element, attrs, ngModel) {
            var data = { from: null, to: null };
            var operations = {
                getValue: function (value, regex) {
                    if (value) {
                        var matchGroups = regex.exec(value);
                        return matchGroups[1] === '*' ? Infinity : Number(matchGroups[1]);
                    }
                    return Infinity;
                },
                validate: function (value) {
                    var num = Number(value);
                    if (num !== isNaN) {
                        ngModel.$setValidity('range', (data.from <= value && value <= data.to));
                    }
                    return value;
                }
            };
            var fromMatch = attrs.sahlRange.match(fromFilter);
            var toMatch = attrs.sahlRange.match(toFilter);
            if ((preFromFilter.test(attrs.sahlRange) && !fromMatch) || (preToFilter.test(attrs.sahlRange) && !toMatch)) {
                ngModel.$setValidity('range', false);
                throw 'Invalid input format, sahl-range=\'from:[ number | * ],to:[ number | * ]\'';
            }
            else {
                if (ngModel) {
                    data.from = operations.getValue(fromMatch, fromFilter);
                    if (data.from === Infinity) {
                        data.from = -Infinity;
                    }
                    data.to = operations.getValue(toMatch, toFilter);
                    ngModel.$parsers.push(operations.validate);
                    ngModel.$formatters.push(operations.validate);
                }
            }
        }
    };
});
angular.module('sahl.js.ui.forms.validation')
.directive('sahlType', function () {
    return {
        
        restrict: 'A',
        require: 'ngModel',
        link: function (scope, element, attrs, ngModel) {
            var data = {
                restriction: null
            };
            var operations = {
                validate: function (value) {
                    if (value) {
                        if (data.restriction === "number") {
                            ngModel.$setValidity('type', (!isNaN(value)));
                        }
                        else{
                            ngModel.$setValidity('type', true);
                        }
                    }
                    return value;
                }
            };

            data.restriction = attrs.sahlType;

            if (ngModel) {
                ngModel.$parsers.push(operations.validate);
                ngModel.$formatters.push(operations.validate);
            }
        }
    };
});
angular.module('sahl.js.ui.templates',[]);