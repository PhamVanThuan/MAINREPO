'use strict';
angular.module('sahl.js.core.applicationManagement', [
    'sahl.js.core.userManagement',
    'sahl.js.core.serviceManagement',
    'sahl.js.core.eventAggregation']);
angular.module('sahl.js.core.documentManagement', [
	'sahl.js.core.activityManagement',
    'sahl.js.core.eventAggregation',
	'sahl.js.core.primitives',
    'sahl.js.core.logging']);
angular.module('sahl.js.core.fluentRestQuery', []);

angular.module('sahl.js.core.logging', []);
angular.module('sahl.js.core.messaging', ['sahl.js.core.activityManagement', 'sahl.js.core.userManagement']);
angular.module('sahl.js.core.routing', []);
angular.module('sahl.js.core.templating', [])
angular.module('sahl.js.core.tileManager', [
    'sahl.js.core.logging'
]);

angular.module('sahl.js.core.userManagement', ['sahl.js.core.userProfile', 'sahl.js.core.eventAggregation']);

angular.module('sahl.js.core.documentManagement.types.userprofile', [
        'sahl.js.core.documentManagement'
    ]);
angular.module('sahl.js.core.activityManagement', [])
    .factory('$activityManager', function () {
        var activityListeners = [];
        var keyedActivityListeners = {};
        var runningKeys = [];
        var startCount = 0;

        var service = {
            startActivity: function () {
                startCount++;
            },

            stopActivity: function () {
                startCount--;

                if (startCount <= 0) {
                    while (activityListeners.length > 0) {
                        if (activityListeners[0]) {
                            activityListeners[0]();
                        }
                        activityListeners.shift();
                    }
                }
            },

            startActivityWithKey: function (key) {
                var listeners = keyedActivityListeners[key];
                if (listeners) {
                    for (var i = 0; i <= listeners.length; i++) {
                        if (listeners[i]) {
                            listeners[i].onStartCallback();
                        }
                    }
                }
                runningKeys.push(key);
                service.startActivity();
            },

            stopActivityWithKey: function (key) {
                var listeners = keyedActivityListeners[key];
                if (listeners) {
                    for (var i = 0; i <= listeners.length; i++) {
                        if (listeners[i]) {
                            listeners[i].onStopCallback();
                        }
                    }
                }
                runningKeys = $.grep(runningKeys, function (value) {
                    return value !== key;
                });
                service.stopActivity();
            },

            getActivityWithKey: function (key) {
                var runningKey = $.grep(runningKeys, function (value) {
                    if (value === key) {
                        return value;
                    }
                });
                return runningKey;
            },

            registerSpinListener: function (onStopCallback) {
                activityListeners.push(onStopCallback);
            },

            registerSpinListenerForKey: function (start, stop, key, id) {
                if (!keyedActivityListeners[key]) {
                    keyedActivityListeners[key] = [];
                }
                keyedActivityListeners[key].push({
                    'onStartCallback': start,
                    'onStopCallback': stop,
                    'id': id
                });
                for (var i = 0; i < runningKeys.length; i++) {
                    if (runningKeys[i] === key) {
                        start();
                    }
                }
            },

            removeListenerForKey: function (id, key) {
                var listeners = keyedActivityListeners[key];
                var remainingListeners = [];
                if (listeners) {
                    remainingListeners = $.grep(listeners, function (value) {
                        return value.id === id;
                    });
                }
                keyedActivityListeners[key] = remainingListeners;
            },
            clearRunningKeyedActivities: function () {
                for (var i = 0; i < runningKeys.length; i++) {
                    service.stopActivityWithKey(runningKeys[i]);
                }
            }
        };

        return service;
    });


angular.module('sahl.js.core.applicationManagement')
    .factory('$applicationManagerService', ['$userManagerService', '$startableManagerService', '$q', '$eventAggregatorService', '$logger', '$timeout', '$activityManager', '$rootScope', function ( $userManagerService, $startableManagerService,
            $q, $eventAggregatorService, $logger, $timeout, $activityManager,$rootScope) {
            var applicationStates = {
                NONE: 'None',
                STARTING: 'Starting',
                STARTED: 'Started',
                FAILED: 'Failed'
            };

            var applicationEvents = {
                applicationStarting: 'applicationStarting',
                applicationStarted: 'applicationStarted',
                applicationFailed: 'applicationFailed'
            };

            var currentState = applicationStates.NONE;
            var operations = {
                startApp: function () {
                    var deferred = $q.defer();
                    currentState = applicationStates.STARTING;
                    $rootScope.ApplicationDocuments = {};
                    $activityManager.startActivityWithKey(applicationStates.STARTING);
                    $eventAggregatorService.publish(applicationEvents.applicationStarting);

                    // get the authenticated user
                    var user = $userManagerService.getAuthenticatedUser();

                    // check that it has a role
                    if (user.state === $userManagerService.userStates.VALID) {

                        $startableManagerService.startServices().then(function () {
                            currentState = applicationStates.STARTED;
                            $eventAggregatorService.publish(applicationEvents.applicationStarted);
                            $activityManager.stopActivityWithKey(applicationStates.STARTING);
                            deferred.resolve();
                        }, function () {
                            currentState = applicationStates.FAILED;
                            $eventAggregatorService.publish(applicationEvents.applicationFailed);
                            $activityManager.stopActivityWithKey(applicationStates.STARTING);
                            deferred.reject();
                        });
                    } else {
                        currentState = applicationStates.FAILED;
                        $logger.logInfo(user.state);
                        $eventAggregatorService.publish(applicationEvents.applicationFailed);
                        $activityManager.stopActivityWithKey(applicationStates.STARTING);
                        deferred.reject();
                    }
                    return deferred.promise;
                }
            };

            return {
                applicationStates: applicationStates,
                applicationEvents: applicationEvents,
                startApp: operations.startApp,
                getCurrentState: function () {
                    return currentState;
                }
            };
        }
    ]);

angular.module('sahl.js.core.applicationManagement')
.service('$documentApplicationService', function () {
    var registeredDocumentApplications = [];

    var models = {
        documentApplication: function (appName, blurb, url, image, order) {
            this.appName = appName;
            this.blurb = blurb;
            this.url = url;
            this.image = image;
            this.order = order;
        }
    };

    var operations = {
        register: function (appName, blurb, url, image, order) {
            var newDocumentApplication = new models.documentApplication(appName, blurb, url, image, order);
            registeredDocumentApplications.push(newDocumentApplication);
        },
        getDocumentApplications : function(){
            return registeredDocumentApplications;
        }
    };

    return {
        register: operations.register,
        getDocumentApplications : operations.getDocumentApplications
    };
});


angular.module('sahl.js.core.applicationManagement')
    .service('$navigationService', function () {
            //empty service for now, gets decorated with actual implementation in app.
            //this is just an interface
            var internal = {
                empty: function () {
                }
            };
            return {
                goHome: internal.empty,
                goClient: internal.empty,
                goTasks: internal.empty,
                goApps: internal.empty,
                goTo: internal.empty
            };
        });

angular.module('sahl.js.core.applicationModules', [])
.service('$charmManagerService', function () {
    var charms = {};
    var internal = {
        registerCharm: function (group, name, module, icon, action, verb) {
            if (!charms[group]) {
                charms[group] = [];
            }
            charms[group].push({ 'name': name, 'icon': icon, 'module': module, 'action': action, 'verb': verb });
        },
        getCharmsForGroup: function (group) {
            return charms[group];
        }
    };
    return {
        registerCharm: internal.registerCharm,
        getCharmsForGroup: internal.getCharmsForGroup
    };
});

angular.module('sahl.js.core.arrays', [])
.service('$arrayHelperService', function () {
    var internal = {
        comparator: function (array, comparisonFn, selector) {
            if (array && selector && array.length > 0) {
                var retVal = selector(array[0]);
                for (var i = 1, c = array.length; i < c; i++) {
                    retVal = comparisonFn(retVal, selector(array[i]));
                }
                return retVal;
            }
            return undefined;
        },
        min:function(array,selector){
            return internal.comparator(array, Math.min, selector);
        },
        max: function (array, selector) {
            return internal.comparator(array, Math.max, selector);
        }
    };

    return {
        min:internal.min,
        max:internal.max
    };
});


angular.module('sahl.js.core.documentManagement')
   .service('$documentManagerService', ['$q', '$documentService', '$documentVersionManagerService', '$guidService', function ($q,$documentService,$documentVersionManagerService,$guidService) {
		   var operations = {
			   newFromExistingDocument : function(document){
				   var newDocument = angular.fromJson(angular.toJson(document))
				   newDocument.id = $guidService.newComb();
				   return newDocument;
			   },
			   newDocument : function(documentType){
				   var document = new $documentVersionManagerService.emptyDocument(documentType);
				   document.id = $guidService.newComb();
				   return document;
			   },
			   openDocumentById : function(id){
				   var deferred = $q.defer();
				   $documentService.getDocumentById(id).then(function(data){
						var jsonDoc = data.data.ReturnData.Results.$values[0];
						if(_.isEmpty(jsonDoc)){
							deferred.reject("failed to load document with id "+ id);
						}else{
							var doc = $documentVersionManagerService.loadDocument(angular.fromJson(jsonDoc.JsonDocument));
							deferred.resolve(doc);
						}
				   },deferred.reject);
				   return deferred.promise;
			   },
			   openDocumentByName : function(name,documentType){
				   var deferred = $q.defer();
				   $documentService.getDocumentByNameAndType(name,documentType).then(function(data){
					   var jsonDoc = data.data.ReturnData.Results.$values[0];
					   if(_.isEmpty(jsonDoc)){
						   var doc = operations.newDocument(documentType);
						   doc.name = name;
						   deferred.resolve(doc);
					   }else{
							var doc = $documentVersionManagerService.loadDocument(angular.fromJson(jsonDoc.JsonDocument));
							deferred.resolve(doc);
					   }
				   },deferred.reject);
				   return deferred.promise;
			   },
			   saveDocument:function(document){
				   var deferred = $q.defer();
				   $documentService.createOrUpdateDocument(document).then(deferred.resolve,deferred.reject);
				   return deferred.promise;
			   },
			   saveDocumentAs:function(document,name){
				   var newDocument = operations.newFromExistingDocument(document);
				   newDocument.name = name;
				   return operations.saveDocument(newDocument);
			   }
		   };

           return {
               newFromExistingDocument: operations.newFromExistingDocument,
               newDocument: operations.newDocument,
               openDocumentById: operations.openDocumentById,
			   openDocumentByName: operations.openDocumentByName,
               //no requirements for this yet closeDocument: function () {},
               saveDocument: operations.saveDocument,
               saveDocumentAs: operations.saveDocumentAs
               //no requirements for this as yet deleteDocument: function () {},
               //no requirements for this as yet getDocumentHistory: function () {}
           };
       }]);

angular.module('sahl.js.core.documentManagement')
.factory('$documentService', function(){
	   return {
		   createOrUpdateDocument : function(){},
		   getDocumentById : function(id){},
		   getDocumentByNameAndType : function(name,type){}
	   };
   });

angular.module('sahl.js.core.documentManagement')
    .factory('$documentVersionManagerService', ['$q', '$eventAggregatorService', '$logger', '$timeout', '$activityManager', function($q, $eventAggregatorService, $logger, $timeout, $activityManager) {

            var versionProviders = [];
            versionProviders.$forDocumentType = function(documentType) {
                return _.find(versionProviders, function(item) {
                    return item.documentType === documentType;
                });
            };

            function getLatestVersion(documentType) {
                var docType = versionProviders.$forDocumentType(documentType);
                if (!_.isUndefined(docType)) {
                    var sorted = _.sortBy(docType.versions, function(item) {
                        return item.version;
                    });
                    return _.last(sorted);
                }
                return undefined;
            }

            return {
                emptyDocument: function(documentType) {
                    var latestVersion = getLatestVersion(documentType);
                    if (!_.isUndefined(latestVersion)) {
                        var latestProvider = latestVersion.provider;
                        return latestProvider.emptyDocument();
                    } else {
                        return undefined;
                    }
                },
                loadDocument: function(document) {
                    var loadedDocument = document;

                    var documentDataVersion = loadedDocument.documentFormatVersion;
                    var documentVersions = versionProviders.$forDocumentType(loadedDocument.documentType);

                    if (_.isUndefined(documentVersions)) {
                        return loadedDocument;
                    }
                    var sortedDocumentVersions = _.sortBy(documentVersions.versions, function(item) {
                        return item.version;
                    });

                    var reachedStart = false;
                    _.each(sortedDocumentVersions, function(documentFormatVersion) {
                        if (documentFormatVersion.version === documentDataVersion) {
                            reachedStart = true;

                        } else {

                            if (reachedStart){

                                loadedDocument = documentFormatVersion.provider.loadDocument(loadedDocument);
                                loadedDocument.documentFormatVersion = documentFormatVersion.version;
                            }
                        }
                    });

                    if (reachedStart) {
                        return loadedDocument;
                    } else {
                        return undefined;
                    }
                },
                registerProvider: function(version, provider) {
                    var docType = versionProviders.$forDocumentType(provider.documentType);

                    if (_.isUndefined(docType)) {
                        versionProviders.push({
                            documentType: provider.documentType,
                            versions: [{
                                "version": version,
                                "provider": provider
                            }]
                        });
                    } else {
                        var provVersion = _.find(docType.versions, function(item) {
                            return item.version === version;
                        });

                        if (_.isUndefined(provVersion)) {
                            docType.versions.push({
                                "version": version,
                                "provider": provider
                            });
                        }
                    }
                },
                $providers: function() {
                    return versionProviders;
                }

            };
        }
    ]);

angular.module('sahl.js.core.eventAggregation', [])
.service('$eventAggregatorService', function () {
    var messageHandlers = [];
    var keyInUse = '';
    var toRemoveFromKeyInUse = [];

    var operations = {
        subscribe: function (messageKey, messageHandler) {
            var messageHandlersForMessageKey;
            var keyValuePair = messageHandlers.filter(function (existingMessageHandlerKey) {
                return existingMessageHandlerKey.key === messageKey;
            });
            if (keyValuePair.length > 0) {
                messageHandlersForMessageKey = keyValuePair[0].value;
            }
            if (messageHandlersForMessageKey === undefined) {
                messageHandlersForMessageKey = [messageHandler];
                messageHandlers.push({
                    key: messageKey,
                    value: messageHandlersForMessageKey
                });
            } else {
                if (!messageHandlersForMessageKey.some(function (existingMessageHandler) {
                    return existingMessageHandler === messageHandler;
                })) {
                    messageHandlersForMessageKey.push(messageHandler);
                }
            }
        },
        unsubscribe: function (messageKey, messageHandler) {
            if (keyInUse === messageKey) {
                toRemoveFromKeyInUse.push({
                    key: messageKey,
                    value: messageHandler
                });
            } else {
                var messageHandlersForMessageKey;
                var keyValuePair = messageHandlers.filter(function (existingMessageHandlerKey) {
                    return existingMessageHandlerKey.key === messageKey;
                });

                messageHandlersForMessageKey = keyValuePair[0].value;

                var index = messageHandlersForMessageKey.indexOf(messageHandler);

                if (index > -1) {
                    messageHandlersForMessageKey.splice(index, 1);
                    if (messageHandlersForMessageKey.length === 0) {
                        index = messageHandlers.indexOf(keyValuePair[0]);
                        messageHandlers.splice(index, 1);
                    }
                }
            }
        },
        publish: function (messageKey, message) {
            keyInUse = messageKey;

            var messageHandlersForMessageKey;
            var keyValuePair = messageHandlers.filter(function (existingMessageHandlerKey) {
                return existingMessageHandlerKey.key === messageKey;
            });
            if (keyValuePair.length > 0) {
                messageHandlersForMessageKey = keyValuePair[0].value;
                for (var i = 0; i < messageHandlersForMessageKey.length; i++) {
                    if (messageHandlersForMessageKey[i] !== undefined) {
                        messageHandlersForMessageKey[i](message);
                    }
                }
            }

            if (toRemoveFromKeyInUse.length > 0) {
                for (var j = 0, c = toRemoveFromKeyInUse.length; j < c; j++) {
                    operations.unsubscribe(toRemoveFromKeyInUse[j].key, toRemoveFromKeyInUse[j].value);
                }
            }

            keyInUse = '';
            toRemoveFromKeyInUse.length = 0;
        },
        clear: function () {
            messageHandlers.length = 0;
        }
    };

    return {
        publish: function (messageKey, message) {
            operations.publish(messageKey, message);
        },
        subscribe: function (messageKey, messageHandler) {
            operations.subscribe(messageKey, messageHandler);
        },
        unsubscribe: function (messageKey, messageHandler) {
            operations.unsubscribe(messageKey, messageHandler);

        },
        clear: function () {
            operations.clear();
        },
        start: function () { },
        getNumberOfRegisteredSubscribers: function () {
            return messageHandlers.length;
        },
        getNumberOfRegisteredSubscribersForEvent: function (messageKey) {
            var keyValuePairs = messageHandlers.filter(function (existingMessageHandlerKey) {
                return existingMessageHandlerKey.key === messageKey;
            });

            return keyValuePairs.length;
        }
    };
});


angular.module('sahl.js.core.fluentDecorator', [])
    .provider('$fluentDecorator', ['$provide', function FluentDecoratorProvider($provide) {
        var fluentDecorator = function (targetProvider) {
            var base = this;
            var target = targetProvider;
            base.with = function (decoratorFunction) {
                $provide.decorator(target, decoratorFunction);
                return base;
            };
            return base;
        };

        this.decorate = function (targetProvider) {
            return new fluentDecorator(targetProvider);
        };

        this.$get = function FluentDecoratorFactory() {
            return {};
        };
    }]);
angular.module('sahl.js.core.fluentRestQuery').factory('$fluentRestQuery', ['$fluentWhereBuilder', '$orderByDirectionBuilder', function ($fluentWhereBuilder, $orderByDirectionBuilder) {
    return function (controllerRoute) {

        var internals = {
            route: (function () {
                if (!controllerRoute.parameters) {
                    return controllerRoute.route;
                }
                return controllerRoute.route.replace(/{(\d+)}/g, function (match, number) {
                    return typeof(controllerRoute.parameters[number])? controllerRoute.parameters[number]: match;
                });
            })(),
            whereBuildingTemplate: $fluentWhereBuilder,
            filterJson: {},
            pagingJson: {},
            //from stack overflow http://stackoverflow.com/a/4994244
            isEmpty: function (obj) {
                for (var key in obj) {
                    if (hasOwnProperty.call(obj, key)) {
                        return false;
                    }
                }
                return true;
            },
            filterJsonIsEmpty: function () {
                return internals.isEmpty(internals.filterJson);
            },
            pagingJsonIsEmpty: function () {
                return internals.isEmpty(internals.pagingJson);
            },
            isOrdered: function () {
                return internals.filterJson.order;
            }
        };

        var queryStringCompiler = {
            queryString: '',
            compilingInQueryString: ['filter', 'paging'],
            compileNewQueryString: function () {
                queryStringCompiler.queryString = '';

                queryStringCompiler.compilingInQueryString.forEach(function (item) {
                    if (!internals[(item + 'JsonIsEmpty')]()) {
                        queryStringCompiler.appendToQueryString(item + '=' + angular.toJson(internals[item + 'Json']));
                    }
                });
            },
            appendToQueryString: function (additional) {
                queryStringCompiler.queryString += (queryStringCompiler.queryString === '' ? '?' : '&') + additional;
            }
        };


        var pagingBuilder = {
            paging: function (pageNumber, pageSize) {
                internals.pagingJson = {Paging: {currentPage: pageNumber, pageSize: pageSize}};
            }
        };

        var filterBuilder = {
            limit: function (num) {
                if (internals.isOrdered()) {
                    internals.filterJson.limit = num;
                }
                else {
                    throw new Error('Query must first be ordered');
                }
            },
            skip: function (num) {
                if (internals.isOrdered()) {
                    internals.filterJson.skip = num;
                }
                else {
                    throw new Error('Query must first be ordered');
                }
            },
            fields: function () {
                if (!internals.filterJson.fields) {
                    internals.filterJson.fields = {};
                }
                var counter = 0;
                var argumentsLength = arguments.length;
                for (; counter < argumentsLength; counter++) {
                    var argument = arguments[counter];
                    internals.filterJson.fields[argument] = true;
                }
            },
            include: function (arrayOfRelationships) {
                arrayOfRelationships.forEach(function (item) {
                    if (!internals.filterJson.include) {
                        internals.filterJson.include = '';
                    }
                    else {
                        internals.filterJson.include += ', ';
                    }
                    internals.filterJson.include += item;
                });
            }
        };

        var thisInstance = this;

        this.paging = function (pageNumber, pageSize) {
            pagingBuilder.paging(pageNumber, pageSize);
            return thisInstance;
        };
        this.limit = function (toAmount) {
            filterBuilder.limit(toAmount);
            return thisInstance;
        };
        this.skip = function (numberToSkip) {
            filterBuilder.skip(numberToSkip);
            return thisInstance;
        };
        this.order = function (placementInOrdering, fieldName) {
            return new $orderByDirectionBuilder(function (direction) {
                if (!internals.filterJson.order) {
                    internals.filterJson.order = {};
                }
                internals.filterJson.order[placementInOrdering] = fieldName + ' ' + direction;
                return thisInstance;
            });
        };
        this.where = function (fieldName) {
            return new internals.whereBuildingTemplate(fieldName, function (whereJson) {
                internals.filterJson.where = whereJson;
                return thisInstance;
            });
        };
        this.fields = function () {
            filterBuilder.fields.apply(this, arguments);
            return thisInstance;
        };
        this.include = function (arrayOfRelationships) {
            filterBuilder.include(arrayOfRelationships);
            return thisInstance;
        };
        this.compiledUrl = function () {
            queryStringCompiler.compileNewQueryString();

            return internals.route + queryStringCompiler.queryString;
        };
    };
}]);
angular.module('sahl.js.core.fluentRestQuery').factory('$orderByDirectionBuilder', function () {
    return function (returningFunction) {
        return {
            ascending: function () {
                return returningFunction('asc');
            },
            descending: function () {
                return returningFunction('desc');
            }
        };
    };
});

angular.module('sahl.js.core.fluentRestQuery').factory('$fluentWhereBuilder', function () {
    return function (fieldName, originalFluentBuilderCallback) {

        var internals = {
            checkingFieldName: fieldName,
            logicalOperatorOptions: {AND: {AND: {}}, OR: {OR: {}}},
            chosenLogicalOperatorOption: null,
            innerWhereJson: {},
            addToFilter: function (type, name, value) {
                if (!internals.innerWhereJson[type]) {
                    internals.innerWhereJson[type] = {};
                }
                internals.innerWhereJson[type][name] = value;
            }

        };


        var functionsForWhereBuilder = {
            greaterThan: function (comparedValue) {
                internals.addToFilter('gt', internals.checkingFieldName, comparedValue);
                return functionsForWhereBuilder;
            },
            lessThan: function (comparedValue) {
                internals.addToFilter('lt', internals.checkingFieldName, comparedValue);
                return functionsForWhereBuilder;
            },
            greaterThanOrEquals: function (comparedValue) {
                internals.addToFilter('gte', internals.checkingFieldName, comparedValue);
                return functionsForWhereBuilder;
            },
            lessThanOrEquals: function (comparedValue) {
                internals.addToFilter('lte', internals.checkingFieldName, comparedValue);
                return functionsForWhereBuilder;
            },
            startsWith: function (comparedValue) {
                internals.addToFilter('startswith', internals.checkingFieldName, comparedValue);
                return functionsForWhereBuilder;
            },
            endsWith: function (comparedValue) {
                internals.addToFilter('endswith', internals.checkingFieldName, comparedValue);
                return functionsForWhereBuilder;
            },
            contains: function (comparedValue) {
                internals.addToFilter('contains', internals.checkingFieldName, comparedValue);
                return functionsForWhereBuilder;
            },
            isLike: function (comparedValue) {
                internals.addToFilter('like', internals.checkingFieldName, comparedValue);
                return functionsForWhereBuilder;
            },
            isEqual: function (comparedValue) {
                internals.addToFilter('eq', internals.checkingFieldName, comparedValue);
                return functionsForWhereBuilder;
            },
            andWhere: function (fieldName) {
                if (internals.chosenLogicalOperatorOption === null) {
                    internals.chosenLogicalOperatorOption = internals.logicalOperatorOptions.AND;
                }
                else if (internals.chosenLogicalOperatorOption === internals.logicalOperatorOptions.OR) {
                    throw new Error("can currently only build with and OR or operations exclusively");
                }
                internals.checkingFieldName = fieldName;
                return functionsForWhereBuilder;
            },
            orWhere: function (fieldName) {
                if (internals.chosenLogicalOperatorOption === null) {
                    internals.chosenLogicalOperatorOption = internals.logicalOperatorOptions.OR;
                }
                else if (internals.chosenLogicalOperatorOption === internals.logicalOperatorOptions.AND) {
                    throw new Error("can currently only build with and OR or operations exclusively");
                }
                internals.checkingFieldName = fieldName;
                return functionsForWhereBuilder;
            },
            endWhere: function () {
                if (!internals.chosenLogicalOperatorOption) {
                    return originalFluentBuilderCallback(internals.innerWhereJson);
                }
                var returningJson = internals.chosenLogicalOperatorOption;
                returningJson[Object.keys(returningJson)[0]] = internals.innerWhereJson;
                return originalFluentBuilderCallback(returningJson);
            }
        };

        return functionsForWhereBuilder;

    };
});

angular.module('sahl.js.core.logging')
.provider('$globalLogger', function () {


    this.decoration = ['$delegate', '$injector','$window', function ($delegate, $injector,$window) {
        var $logger;
        return function (exception, cause) {
            $delegate(exception, cause);
            $logger = $logger || $injector.get('$logger');
            $logger.logError(exception.message, exception.stack);
            throw exception;
        };
    }];


    this.$get = function GlobalLoggerFactory() { };
});
angular.module('sahl.js.core.logging')
    .service('$logger', ['$loggingService', function ($loggingService) {
            var rawLogger = {
                func: null,
                instance: null
            };

            rawLogger.func = console.log;
            rawLogger.instance = this;
            var operations = {
                start: function () {
                    console.log = function () {
                    };
                },
                logInfo: function (message) {
                    try {
                        $loggingService.logInfo(message);
                    } catch (err) {
                        rawLogger.func.call(console, "logging service unavailable");
                    }
                },
                logWarning: function (message) {
                    try {
                        $loggingService.logWarning(message);
                    } catch (err) {
                        rawLogger.func.call(console, "logging service unavailable");
                    }
                },
                logError: function (message, stackTrace) {
                    try {
                        $loggingService.logError(message, stackTrace);
                    } catch (err) {
                        rawLogger.func.call(console, "logging service unavailable");
                    }
                }
            };

            if (window.debug) {
                operations.start = function () {
                    console.log = function () {
                        rawLogger.func.call(console, 'Notice! console.log has been depricated!\nuse $logger within the "sahl.js.core.logging" module\nother options:\n$logger.logInfo\n$logger.logWarning\n$logger.logError');
                        rawLogger.func.call(console, arguments);
                    };
                };
                operations.logInfo = function (message) {
                    rawLogger.func.call(console, message);
                };
                operations.logWarning = function (message) {
                    rawLogger.func.call(console, message);
                };
                operations.logError = function (message, stackTrace) {
                    rawLogger.func.call(console, message + "\r\n" + stackTrace);
                };
            }

            return {
                start: operations.start,
                logInfo: operations.logInfo,
                logWarning: operations.logWarning,
                logError: operations.logError
            };
        }]);

angular.module('sahl.js.core.logging')
.service('$loggingService', function () {
    //empty service for now, gets decorated with actual implementation in app.
    //this is just an interface
    var operations = {
        logInfo: function (message) {},
        logWarning: function (message) {},
        logError: function (message, stackTrace) {}
    };
    return {
        logInfo: operations.logInfo,
        logWarning: operations.logWarning,
        logError: operations.logError
    };
});

angular.module('sahl.js.core.lookup', [])
    .service('$lookupService', ['$q', function ($q) {
        var operations = {
            getByLookupType: function (lookupType) {},
            getByLookupTypeId: function (lookupType, id) {},
            getByLineItemCategoryId: function (id) {}
        };
        return {
            getByLookupType: operations.getByLookupType,
            getByLookupTypeId: operations.getByLookupTypeId,
            getByLineItemCategoryId:operations.getByLineItemCategoryId
        };
    }]);


angular.module('sahl.js.core.messaging')
    .provider('$activityDecorator', function () {
        this.decoration = ['$delegate', '$q', '$activityManager', function ($delegate, $q, $activityManager) {
            return {
                postMessage: function (messageToSend, url) {
                    var deferred = $q.defer();
                    $activityManager.startActivity();
                    $delegate.postMessage(messageToSend, url).then(function (data) {
                        $activityManager.stopActivity();
                        deferred.resolve(data);
                    }, function (errorMsg) {
                        $activityManager.stopActivity();
                        deferred.reject(errorMsg);
                    });
                    return deferred.promise;
                },
                getMessage:function(url){
                    var deferred = $q.defer();
                    $activityManager.startActivity();
                    $delegate.getMessage(url).then(function (data) {
                        $activityManager.stopActivity();
                        deferred.resolve(data);
                    }, function (errorMsg) {
                        $activityManager.stopActivity();
                        deferred.reject(errorMsg);
                    });
                    return deferred.promise;
                }
            };
        }];

        this.$get = function DecoratorFactory() {
        };
    });

angular.module('sahl.js.core.messaging')
.factory('$authInterceptor', ['$q', '$authenticatedUser', function ($q, $authenticatedUser) {
    var meta_prefix = "#md#_";
    var authInterceptor = {
        request: function(config){
            if ($authenticatedUser) {
                config.headers[meta_prefix + 'OrganisationArea'] = $authenticatedUser.currentOrgRole.OrganisationArea;
                config.headers[meta_prefix + 'currentuserrole'] = $authenticatedUser.currentOrgRole.RoleName;
                config.headers[meta_prefix + 'username'] = $authenticatedUser.adName;
                config.headers[meta_prefix + 'UserOrganisationStructureKey'] = $authenticatedUser.currentOrgRole.UserOrganisationStructureKey;
				
            }
            return config;
        }
    };
    
    return authInterceptor;
}]);
angular.module('sahl.js.core.messaging')
    .factory('$messageManager', ['$http', '$q', function($http, $q) {
            return {
                postMessage: function(messageToSend, url) {
                    var deferred = $q.defer();
                    var json = angular.fromJson(messageToSend);
                    $http.post(url, json).success(function(data, status, headers) {
                        deferred.resolve({
                            data: data,
                            status: status,
                            headers: headers
                        });
                    }).error(function(reason, status, headers) {
                            deferred.reject({
                                data: reason,
                                status: status,
                                headers: headers
                            });
                    });
                return deferred.promise;
            },
            getMessage: function(url) {
                var deferred = $q.defer();
                $http.get(url).success(function(data, status, headers) {
                    deferred.resolve({
                        data: data,
                        status: status,
                        headers: headers
                    });
                }).error(function() {
                    deferred.reject('An error occurred while accessing the service over http.');
                });
                return deferred.promise;
            }
        };
    }]);


angular.module('sahl.js.core.signalR', [
    'sahl.js.core.logging'
])
    .factory('$signalRHubManager', ['$rootScope', '$q', '$logger', function ($rootScope, $q, $logger) {
            function signalRHubProxyFactory(serverUrl, hubName, startOptions) {
                var connection = $.hubConnection(serverUrl);
                var proxy = connection.createHubProxy(hubName);

                return {
                    start: function () {
                        var deferred = $q.defer();

                        connection.start(startOptions)
                            .done(function () {
                                $logger.logInfo('Connection created to hub: ' + hubName);
                                deferred.resolve();
                            })
                            .fail(function () {
                                $logger.logInfo('Could not connect!');
                                deferred.reject();
                            });

                        return deferred.promise;
                    },
                    on: function (eventName, callback) {
                        proxy.on(eventName, function (result) {
                            $rootScope.$apply(function () {
                                if (callback) {
                                    callback(result);
                                }
                            });
                        });
                    },
                    off: function (eventName, callback) {
                        proxy.off(eventName, function (result) {
                            $rootScope.$apply(function () {
                                if (callback) {
                                    callback(result);
                                }
                            });
                        });
                    },
                    invoke: function (methodName, methodParameters) {
                        var deferred = $q.defer();

                        proxy.invoke(methodName, methodParameters)
                            .done(function (result) {
                                $rootScope.$apply(function () {
                                    deferred.resolve(result);
                                });
                            })
                            .fail(function (error) {
                                deferred.reject(error);
                            });

                        return deferred.promise;
                    },
                    connection: connection
                };
            };

            return signalRHubProxyFactory;
        }]);

angular.module('sahl.js.core.primitives', [])
.service('$guidService', function () {
    var internal = {
        LongToByteArray: function (longvalue) {
            var byteArray = [0, 0, 0, 0, 0, 0, 0, 0];

            for (var index = 0; index < byteArray.length; index++) {
                var abyte = longvalue & 0xff;
                byteArray[index] = abyte;
                longvalue = (longvalue - abyte) / 256;
            }
            return byteArray;
        },
        BytesToHex : function(bytes){
            for (var hex = [], i = 0; i < bytes.length; i++) {
                hex.push((bytes[i] >>> 4).toString(16));
                hex.push((bytes[i] & 0xF).toString(16));
            }
            return hex.join("");
        },
        guidFromPattern: function (pattern) {
            return pattern.replace(/[xy]/g, function (c) {
                var r = Math.random() * 16 | 0,
                    v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }
    };
    var operations = {
        newGuid : function(){
            var guidPattern = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx';
            return internal.guidFromPattern(guidPattern);
        },
        newComb: function () {
            var combPattern = 'xxxxxxxx-xxxx-4xxx-yxxx-';
            var comb = internal.guidFromPattern(combPattern);

            var days = moment().diff(moment([1900, 1, 1]), 'days');
            var daysBytes = internal.LongToByteArray(days).reverse();
            daysBytes = daysBytes.slice(daysBytes.length - 2);
            var daysHex = internal.BytesToHex(daysBytes);
            var msecs = Math.floor(moment().diff(moment().startOf('day')) / 3.333333);
            var msecsBytes = internal.LongToByteArray(msecs).reverse();
            msecsBytes = msecsBytes.slice(msecsBytes.length - 4);
            var msecsHex = internal.BytesToHex(msecsBytes);
            comb = comb + daysHex + msecsHex;
            return comb;
        }
    };
    return {
        newGuid: operations.newGuid,
        newComb : operations.newComb
    };
});

angular.module('sahl.js.core.routing')
.provider('$uiStateDecorator', function () {
    this.decoration = ['$delegate', '$uiStateManagerService', '$rootScope', function ($delegate, $uiStateManagerService, $rootScope) {

        $rootScope.$on('$stateChangeStart', function () {
            $uiStateManagerService.transition(arguments[2]);
        });

        var goFn = $delegate.go;

        $delegate.go = function () {
            if (arguments[1] && arguments[1] instanceof Object) {
                $uiStateManagerService.set(arguments[1]);
            }
            goFn.apply(this, arguments);
        };

        return $delegate;
    }];

    this.$get = function DecoratorFactory() {
    };
});
angular.module('sahl.js.core.routing')
    .service('$uiStateManagerService', function () {
        var store = {};
        var operations = {
            set: function (model) {
                store = model;
            },
            transition: function (stateParams) {
                if (store instanceof Object && !(store instanceof Array)) {
                    for (var modelName in store) {
                        if (store.hasOwnProperty(modelName)) {
                            stateParams[modelName] = store[modelName];
                        }
                    }
                }
                store = {};
            }
        };
        return {
            set: operations.set,
            transition: operations.transition
        };
    });

angular.module('sahl.js.core.serviceManagement', [])
    .service('$startableManagerService', ['$q', '$timeout', function ($q, $timeout) {
            var operations = {
                startServices: function () {
                    var waitableServices = [];
                    angular.forEach(arguments, function (value) {
                        if (value['start'] !== undefined) {
                            var result = value.start();
                            if (result !== undefined && result['then']) {
                                waitableServices.push(result);
                            }
                        }
                    });
                    return $q.all(waitableServices);
                }
            };

            return {
                startServices: operations.startServices
            };
        }
    ]);

angular.module('sahl.services.config',[]);

angular.module('sahl.js.core.templating')
.service('$templateManagerService', ['$q', '$http', '$templateCache', function ($q, $http, $templateCache) {
    var operations = {
        get: function (templateUrl) {
            var deferred = $q.defer();
            $http.get(templateUrl, { cache: $templateCache }).then(function (response) {
                deferred.resolve(response.data);
            });
            return deferred.promise;
        }
    };
    return {
        get: operations.get
    };
}]);

angular.module('sahl.js.core.tileManager')
    .service('$tileManagerService', ['$tileManagerConfigurationService', '$q', function($tileManagerConfigurationService, $q) {
            var operations = {
                loadApplicationConfiguration: function(applicationName) {
                    var deferred = $q.defer();

                    $tileManagerConfigurationService.getApplicationConfiguration(applicationName).then(function(applicationConfiguration) {
                        deferred.resolve(applicationConfiguration);
                    }, function() {
                        deferred.reject();
                    });

                    return deferred.promise;
                },
                loadModuleConfiguration: function(applicationName, moduleName, returnAllRoots, moduleParameters, roleName, capabilities) {
                    var deferred = $q.defer();

                    $tileManagerConfigurationService.getModuleConfiguration(applicationName, moduleName, returnAllRoots, moduleParameters, roleName, capabilities).then(function(moduleConfiguration) {
                        deferred.resolve(moduleConfiguration);
                    }, function() {
                        deferred.reject();
                    });

                    return deferred.promise;
                },
                loadApplicationMenuItems: function(applicationName) {
                    var deferred = $q.defer();

                    $tileManagerConfigurationService.getApplicationConfigurationMenuItems(applicationName).then(function(model) {
                        deferred.resolve(model);
                    }, function() {
                        deferred.reject();
                    });

                    return deferred.promise;
                },
                loadRootTileConfiguration: function(applicationName, moduleName, rootTileName, businessContext, businessKeyType, businessKeyValue, roleName, capabilities) {
                    var deferred = $q.defer();

                    $tileManagerConfigurationService.getRootTileConfiguration(applicationName, moduleName, rootTileName, businessContext, businessKeyType, businessKeyValue, roleName, capabilities).then(function(model) {
                        deferred.resolve(model);
                    }, function() {
                        deferred.reject();
                    });

                    return deferred.promise;
                },
                loadWizardConfiguration: function(wizardName, processName, workflowName, activityName, businessContext) {
                    var deferred = $q.defer();

                    $tileManagerConfigurationService.getWizardConfiguration(wizardName, processName, workflowName, activityName, businessContext).then(function(model) {
                        deferred.resolve(model);
                    }, function() {
                        deferred.reject();
                    });

                    return deferred.promise;
                },
                findTileActionsForRootTileConfigurationModel: function(model) {
                    var allTileActions = [];

                    if (model === null) {
                        return allTileActions;
                    }

                    if (model.rootTileConfigurations !== null && model.rootTileConfigurations.$values.length > 0) {
                        var allRootTiles = model.rootTileConfigurations.$values;

                        for (var rootLoop = 0; rootLoop < allRootTiles.length; rootLoop++) {
                            var rootTileConfiguration = allRootTiles[rootLoop];
                            processTileActions(rootTileConfiguration, allTileActions);
                        }
                    }

                    if (model.childTileConfiguratiosn !== null && model.childTileConfigurations.$values.length > 0) {
                        var allChildTiles = model.childTileConfigurations.$values;

                        for (var childLoop = 0; childLoop < allChildTiles.length; childLoop++) {
                            var childTileConfiguration = allChildTiles[childLoop];
                            processTileActions(childTileConfiguration, allTileActions);
                        }
                    }

                    return allTileActions;
                }
            };

            function processTileActions(tileConfiguration, tileActionList) {
                if (tileConfiguration === null ||
                    tileConfiguration.tileActions === null ||
                    tileConfiguration.tileActions.length === 0) {
                    return [];
                }

                var tileActions = tileConfiguration.tileActions.$values;

                for (var tileActionLoop = 0; tileActionLoop < tileActions.length; tileActionLoop++) {
                    if (tileActions[tileActionLoop].actionType === 'Edit' ||
                        tileActions[tileActionLoop].actionType === 'Wizard' ||
                        tileActions[tileActionLoop].actionType === 'Workflow') {
                        var newTileAction = {
                            tileAction: tileActions[tileActionLoop],
                            tileConfiguration: tileConfiguration
                        };

                        tileActionList[tileActionList.length] = newTileAction;
                    }
                }
            }

            return {
                loadApplicationConfiguration: operations.loadApplicationConfiguration,
                loadApplicationMenuItems: operations.loadApplicationMenuItems,
                loadModuleConfiguration: operations.loadModuleConfiguration,
                loadRootTileConfiguration: operations.loadRootTileConfiguration,
                loadWizardConfiguration: operations.loadWizardConfiguration,
                findTileActionsForRootTileConfigurationModel: operations.findTileActionsForRootTileConfigurationModel
            };
        }
    ]);


angular.module('sahl.js.core.tileManager')
    .service('$tileManagerConfigurationService', function() {
        var operations = {
            getAllApplications: function () {},
            getApplicationConfiguration: function(applicationName) {},
            getApplicationConfigurationMenuItems: function(applicationName) {},
            getModuleConfiguration: function(applicationName, moduleName, returnAllRoots, moduleParameters, roleName, capabilities) {},
            getRootTileConfiguration: function (applicationName, moduleName, rootTileName, businessContext, businessKeyType, businessKeyValue, roleName, capabilities) { },
            getWizardConfiguration: function (wizardName, processName, workflowName, activityName, businessContext) { }
        };

        return {
            getAllApplications: operations.getAllApplications,
            getApplicationConfiguration: operations.getApplicationConfiguration,
            getApplicationConfigurationMenuItems: operations.getApplicationConfigurationMenuItems,
            getModuleConfiguration: operations.getModuleConfiguration,
            getRootTileConfiguration: operations.getRootTileConfiguration,
            getWizardConfiguration: operations.getWizardConfiguration
        };
    });


angular.module('sahl.js.core.transactionQueryService',[])
    .service('$transactionQueryService', function() {
        var operations = {
            /** Temp solution : data should be retrieved from query service.**/
            getLoanTransactionDetailData: function(accountKey) {},
            /** Temp solution : data should be retrieved from query service.**/
            getArrearTransactionDetailData: function(businessKey) {}
        };
        return {
            getLoanTransactionDetailData: operations.getLoanTransactionDetailData,
            getArrearTransactionDetailData: operations.getArrearTransactionDetailData
        };
    });

'use strict';
angular.module('sahl.js.core.userManagement').constant('$authenticatedUser', authenticatedUser);
angular.module('sahl.js.core.userManagement')
    .service('$userManagerService', ['$rootScope', '$userProfileService', '$q', '$authenticatedUser', '$eventAggregatorService', function ($rootScope, $userProfileService, $q, $authenticatedUser, $eventAggregatorService) {
            var userStates = {
                NOACCESS: 'NoAccess',
                NOORGROLE: 'NoOrgRole',
                VALID: 'ValidUser'
            };

            var userEvents = {
                OrgRoleChanged: 'orgRoleChanged'
            };

            var operations = {
                getAuthenticatedUser: function () {
                    return {
                        fullAdName: $authenticatedUser.fullAdName,
                        domain: $authenticatedUser.domain,
                        adName: $authenticatedUser.adName,
                        emailAddress: $authenticatedUser.emailAddress,
                        displayName: $authenticatedUser.displayName,
                        currentOrgRole: $authenticatedUser.currentOrgRole,
                        orgRoles: $authenticatedUser.orgRoles,
                        capabilities: $authenticatedUser.capabilities,
                        state: $authenticatedUser.state
                    };
                },
                selectOrgRole: function (role) {
                    if (role && role.UserOrganisationStructureKey !== $authenticatedUser.currentOrgRole.UserOrganisationStructureKey){
						$userProfileService.getCapabilitiesForUserOrganisationStructure(role.UserOrganisationStructureKey).then(function(capabilities){
							$authenticatedUser.capabilities = capabilities;
							$authenticatedUser.currentOrgRole = role;
							$eventAggregatorService.publish(userEvents.OrgRoleChanged, {role:role,capabilities:capabilities});
						});
                    }
                },
                getUserProfile: function () {
                    var deferred = $q.defer();
                    var userProfile = $rootScope.ApplicationDocuments.UserProfile;
                    if (_.isUndefined(userProfile)) {
                        $userProfileService.getUserProfile($authenticatedUser.fullAdName).then(function () {
							var role = _.find($authenticatedUser.orgRoles, function (role) {
								return role.UserOrganisationStructureKey === $rootScope.ApplicationDocuments.UserProfile.document.defaultRole;
							});
							if(_.isEmpty(role)){
								role = $authenticatedUser.currentOrgRole;
							}
							operations.selectOrgRole(role);
                            deferred.resolve($rootScope.ApplicationDocuments.UserProfile.document);
                        });
                    } else {
		                deferred.resolve(userProfile.document);
                    }
                    return deferred.promise;
                },
                saveUserProfile: function (userProfile) {
                    $userProfileService.saveUserProfile(userProfile).then(function () {
                        $userProfileService.getUserProfile($authenticatedUser.fullAdName);
                    });
                }
            };
            return {
                userStates: userStates,
                getAuthenticatedUser: operations.getAuthenticatedUser,
                selectOrgRole: operations.selectOrgRole,
                getUserProfile: operations.getUserProfile,
                saveUserProfile: operations.saveUserProfile
            };
        }
    ]);

angular.module('sahl.js.core.userProfile', [])
    .service('$userProfileService', ['$q', '$rootScope', function ($q, $rootScope) {
        var operations = {
            getUserProfile: function (adName) {},
            saveUserProfile: function (userProfileDocument) {},
			getCapabilitiesForUserOrganisationStructure:function(organisationStructureKey){},
			getCapabilitiesForUser:function(){}
        };
        return {
            getUserProfile: operations.getUserProfile,
            saveUserProfile: operations.saveUserProfile,
			getCapabilitiesForUserOrganisationStructure: operations.getCapabilitiesForUserOrganisationStructure,
			getCapabilitiesForUser: operations.getCapabilitiesForUser
        };
    }]);


angular.module('sahl.js.core.documentManagement.types.decisiontree', [
        'sahl.js.core.documentManagement'
    ])
    .service('$decisiontreeDocumentVersion_0_1', ['$documentVersionManagerService', function($documentVersionManagerService) {
            var provider = {
                documentType: "decisiontree",
                emptyDocument: function() {

                },
                loadDocument: function(document) {
                    return document;
                }
            };

            $documentVersionManagerService.registerProvider("0.1", provider);

            return {
                start: function() {}
            };
        }
    ]);


angular.module('sahl.js.core.documentManagement.types.userprofile')
    .service('$userprofileDocumentVersion_0_1', ['$documentVersionManagerService', function ($documentVersionManagerService) {
            var provider = {
                documentType: "userprofile",
                emptyDocument: function () {
                    return {
                        "id": "",
                        "name": "",
                        "description": "Document containing user profile data",

                        "version": 0,
                        "documentType": "userprofile",
                        "documentFormatVersion": 0.1,
                        "document": {
                            "defaultLandingPage": ""
                        }
                    };



                },
                loadDocument: function (document) {
                    return document;
                }
            };

            $documentVersionManagerService.registerProvider("0.1", provider);

            return {
                start: function () {}
            };
        }
    ]);


angular.module('sahl.js.core.documentManagement.types.userprofile')
    .service('$userprofileDocumentVersion_0_2', ['$documentVersionManagerService', function ($documentVersionManagerService) {
            var provider = {
                documentType: "userprofile",
                emptyDocument: function () {
                    return {
                        "id": "",
                        "name": "",
                        "description": "Document containing user profile data",
                        "version": 0,
                        "documentType": "userprofile",
                        "documentFormatVersion": 0.2,
                        "document": {
                            "defaultLandingPage": "",
                            "searchFilters": ""
                        }
                    };
                },
                loadDocument: function (document) {
                    document.document.searchFilters = "";
                    return document;
                }
            };

            $documentVersionManagerService.registerProvider("0.2", provider);

            return {
                start: function () {}
            };
        }
    ]);


angular.module('sahl.js.core.documentManagement.types.userprofile')
    .service('$userprofileDocumentVersion_0_3', ['$documentVersionManagerService', function ($documentVersionManagerService) {
            var provider = {
                documentType: "userprofile",
                emptyDocument: function () {
                    return {
                        "id": "",
                        "name": "",
                        "description": "Document containing user profile data",
                        "version": 0,
                        "documentType": "userprofile",
                        "documentFormatVersion": 0.3,
                        "document": {
                            "defaultLandingPage": "",
                            "searchFilters": "",
							"defaultRole": ""
                        }
                    };
                },
                loadDocument: function (document) {
                    document.document.defaultRole = "";
                    return document;
                }
            };

            $documentVersionManagerService.registerProvider("0.3", provider);

            return {
                start: function () {}
            };
        }
    ]);

angular.module('sahl.js.core.templates',[]);